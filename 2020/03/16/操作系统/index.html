<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Gavin-操作系统 | Gavin</title>

  <!-- keywords -->
  
    <meta name="keywords" content="Gavin">
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="操作系统操作系统的基本概念 操作系统以下是硬件，以上是编译系统等一些支撑软件或者系统使用软件，再往上是实现各个具体应用任务的应用软件。操作系统是最贴近硬件层的系统软件。  操作系统是人机交互的桥梁，为用户提供人机界面，提供便捷、高效的运行环境和服务。  操作系统管理所有硬件资源；控制调度所有程序的运行过程；通过软件的管理方法虚拟地扩充硬件功能  操作系统的概念：一种管理系统资源、控制程序执行、改善">
<meta name="keywords" content="Gavin">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://yoursite.com/2020/03/16/操作系统/index.html">
<meta property="og:site_name" content="Gavin">
<meta property="og:description" content="操作系统操作系统的基本概念 操作系统以下是硬件，以上是编译系统等一些支撑软件或者系统使用软件，再往上是实现各个具体应用任务的应用软件。操作系统是最贴近硬件层的系统软件。  操作系统是人机交互的桥梁，为用户提供人机界面，提供便捷、高效的运行环境和服务。  操作系统管理所有硬件资源；控制调度所有程序的运行过程；通过软件的管理方法虚拟地扩充硬件功能  操作系统的概念：一种管理系统资源、控制程序执行、改善">
<meta property="og:locale" content="English & Chinese">
<meta property="og:image" content="http://yoursite.com/Pictures/操作系统在计算机系统中的地位.png">
<meta property="og:image" content="http://yoursite.com/Pictures/操作系统的作用.png">
<meta property="og:image" content="http://yoursite.com/Pictures/资源管理技术.png">
<meta property="og:image" content="http://yoursite.com/Pictures/资源虚拟.png">
<meta property="og:image" content="http://yoursite.com/Pictures/操作系统虚拟机.png">
<meta property="og:image" content="http://yoursite.com/Pictures/LInux单体式单内核结构.png">
<meta property="og:image" content="http://yoursite.com/Pictures/微内核操作系统.png">
<meta property="og:image" content="http://yoursite.com/Pictures/PC机开机过程.png">
<meta property="og:image" content="http://yoursite.com/Pictures/PC机开机过程2.png">
<meta property="og:image" content="http://yoursite.com/Pictures/串并发.png">
<meta property="og:image" content="http://yoursite.com/Pictures/进程并发必须解决的问题.png">
<meta property="og:image" content="http://yoursite.com/Pictures/异步性.png">
<meta property="og:image" content="http://yoursite.com/Pictures/批处理作业.png">
<meta property="og:image" content="http://yoursite.com/Pictures/交互型作业.png">
<meta property="og:image" content="http://yoursite.com/Pictures/实时型作业.png">
<meta property="og:image" content="http://yoursite.com/Pictures/硬实时软实时.png">
<meta property="og:image" content="http://yoursite.com/Pictures/作业类别.png">
<meta property="og:image" content="http://yoursite.com/Pictures/假脱机.png">
<meta property="og:image" content="http://yoursite.com/Pictures/批作业与交互作业控制方式的不同.png">
<meta property="og:image" content="http://yoursite.com/Pictures/作业转换图.png">
<meta property="og:image" content="http://yoursite.com/Pictures/操作系统接口.png">
<meta property="og:image" content="http://yoursite.com/Pictures/系统调用.png">
<meta property="og:image" content="http://yoursite.com/Pictures/系统调用的服务例程.png">
<meta property="og:image" content="http://yoursite.com/Pictures/系统调用的前后.png">
<meta property="og:image" content="http://yoursite.com/Pictures/分层关系.png">
<meta property="og:image" content="http://yoursite.com/Pictures/系统调用的处理过程.png">
<meta property="og:image" content="http://yoursite.com/Pictures/作业调度算法.png">
<meta property="og:image" content="http://yoursite.com/Pictures/HRF.png">
<meta property="og:image" content="http://yoursite.com/Pictures/均衡调度算法.png">
<meta property="og:image" content="http://yoursite.com/Pictures/系统吞吐量.png">
<meta property="og:image" content="http://yoursite.com/Pictures/平均周转时间.png">
<meta property="og:image" content="http://yoursite.com/Picture/平均带权周转时间.png">
<meta property="og:image" content="http://yoursite.com/Pictures/其他指标.png">
<meta property="og:image" content="http://yoursite.com/Pictures/作业程序进程.png">
<meta property="og:image" content="http://yoursite.com/Prictures/进程的组成.png">
<meta property="og:image" content="http://yoursite.com/Pictures/进程控制块.png">
<meta property="og:image" content="http://yoursite.com/Pictures/两状态进程模型.png">
<meta property="og:image" content="http://yoursite.com/Pictures/队列轮转图.png">
<meta property="og:image" content="http://yoursite.com/Pictures/三状态基本模型.png">
<meta property="og:image" content="http://yoursite.com/Pictures/状态转换.png">
<meta property="og:image" content="http://yoursite.com/Pictures/一个挂起状态.png">
<meta property="og:image" content="http://yoursite.com/Pictures/两个挂起状态.png">
<meta property="og:image" content="http://yoursite.com/Pictures/PCB队列结构.png">
<meta property="og:image" content="http://yoursite.com/Pictures/进程控制原语.png">
<meta property="og:image" content="http://yoursite.com/Pictures/原语类别.png">
<meta property="og:image" content="http://yoursite.com/Pictures/创建原语运行.png">
<meta property="og:image" content="http://yoursite.com/Pictures/如何运行.png">
<meta property="og:image" content="http://yoursite.com/Pictures/创建原语2.png">
<meta property="og:image" content="http://yoursite.com/Pictures/创建原语3.png">
<meta property="og:image" content="http://yoursite.com/Pictures/创建原语4.png">
<meta property="og:image" content="http://yoursite.com/Pictures/何时撤销.png">
<meta property="og:image" content="http://yoursite.com/Pictures/撤销运行.png">
<meta property="og:image" content="http://yoursite.com/Pictures/撤销原语2.png">
<meta property="og:image" content="http://yoursite.com/Pictures/撤销原语3.png">
<meta property="og:image" content="http://yoursite.com/Pictures/阻塞原语的运行.png">
<meta property="og:image" content="http://yoursite.com/Pictures/fork函数.png">
<meta property="og:image" content="http://yoursite.com/Pictures/fork返回值.png">
<meta property="og:image" content="http://yoursite.com/Pictures/fork失败返回.png">
<meta property="og:image" content="http://yoursite.com/Pictures/测试fork返回值.png">
<meta property="og:image" content="http://yoursite.com/Pictures/多级队列反馈调度算法1.png">
<meta property="og:image" content="http://yoursite.com/Pictures/多级队列反馈调度算法2.png">
<meta property="og:image" content="http://yoursite.com/Pictures/立即抢占.png">
<meta property="og:image" content="http://yoursite.com/Pictures/基于时钟中断抢占.png">
<meta property="og:image" content="http://yoursite.com/Pictures/非抢占的优先级调度算法.png">
<meta property="og:image" content="http://yoursite.com/Pictures/时间片轮转算法.png">
<meta property="og:image" content="http://yoursite.com/Pictures/周期性实时任务.png">
<meta property="og:image" content="http://yoursite.com/Pictures/多线程进程模型.png">
<meta property="og:image" content="http://yoursite.com/Pictures/线程的分类.png">
<meta property="og:image" content="http://yoursite.com/Pictures/三级调度.png">
<meta property="og:image" content="http://yoursite.com/Pictures/用户级线程调度.png">
<meta property="og:image" content="http://yoursite.com/Pictures/内核级线程调度.png">
<meta property="og:image" content="http://yoursite.com/Pictures/线程与子进程调度的区别.png">
<meta property="og:image" content="http://yoursite.com/Pictures/管程结构模型.png">
<meta property="og:image" content="http://yoursite.com/Pictures/资源请求分配图.png">
<meta property="og:image" content="http://yoursite.com/Pictures/资源请求分配矩阵.png">
<meta property="og:image" content="http://yoursite.com/Pictures/资源请求分配矩阵2.png">
<meta property="og:image" content="http://yoursite.com/Pictures/资源请求分配矩阵3.png">
<meta property="og:image" content="http://yoursite.com/Pictures/存储器层次.png">
<meta property="og:image" content="http://yoursite.com/Pictures/各级存储器性能.png">
<meta property="og:image" content="http://yoursite.com/Pictures/程序的编译链接装载和执行.png">
<meta property="og:image" content="http://yoursite.com/Pictures/保护方法.png">
<meta property="og:image" content="http://yoursite.com/Pictures/空闲分区表.png">
<meta property="og:image" content="http://yoursite.com/Pictures/动态多分区存储保护.png">
<meta property="og:image" content="http://yoursite.com/Pictures/记录内存的数据结构.png">
<meta property="og:image" content="http://yoursite.com/Pictures/页表示例.png">
<meta property="og:image" content="http://yoursite.com/Pictures/地址划分.png">
<meta property="og:image" content="http://yoursite.com/Pictures/地址重定位.png">
<meta property="og:image" content="http://yoursite.com/Pictures/地址保护.png">
<meta property="og:image" content="http://yoursite.com/Pictures/地址重定位1.png">
<meta property="og:image" content="http://yoursite.com/Pictures/分段保护.png">
<meta property="og:image" content="http://yoursite.com/Pictures/共享段表实例.png">
<meta property="og:image" content="http://yoursite.com/Pictures/段表和段内页表.png">
<meta property="og:image" content="http://yoursite.com/Pictures/段页式地址重定位.png">
<meta property="og:image" content="http://yoursite.com/Pictures/段页式地址保护.png">
<meta property="og:image" content="http://yoursite.com/Pictures/段页式地址字结构的计算.png">
<meta property="og:updated_time" content="2020-06-19T10:17:18.505Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统">
<meta name="twitter:description" content="操作系统操作系统的基本概念 操作系统以下是硬件，以上是编译系统等一些支撑软件或者系统使用软件，再往上是实现各个具体应用任务的应用软件。操作系统是最贴近硬件层的系统软件。  操作系统是人机交互的桥梁，为用户提供人机界面，提供便捷、高效的运行环境和服务。  操作系统管理所有硬件资源；控制调度所有程序的运行过程；通过软件的管理方法虚拟地扩充硬件功能  操作系统的概念：一种管理系统资源、控制程序执行、改善">
<meta name="twitter:image" content="http://yoursite.com/Pictures/操作系统在计算机系统中的地位.png">
  
    <link rel="alternative" href="/atom.xml" title="Gavin" type="application/atom+xml">
  
  
    <link rel="icon" href="https://weizheblog.gitee.io/Pictures/timg.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
      <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("your_app_id", "your_app_key");</script>
<script src="/js/Counter.js"></script>
  
</head></html>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://weizheblog.gitee.io/Pictures/timg.ico" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Weizhe Yang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Gavin</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/GavinWz/" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/HPC/" style="font-size: 10px;">HPC</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.iczc.me/">iczc</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">A student of the College of Computer Engineering of Weifang University. I&#39;m learning hard on Information Technology, and this is where I save my study records.Not all the essays here are my original works, but some of them have helped me a lot in the past time, so I recorded them to share with everyone and it also remind me what should I do if I face the same situations which I have met in the past but forgot how to operate now.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Weizhe Yang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://weizheblog.gitee.io/Pictures/timg.ico" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Weizhe Yang</h1>
			</hgroup>
			
			<p class="header-subtitle">Gavin</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/GavinWz/" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/16/操作系统/" class="article-date">
  	<time datetime="2020-03-16T07:42:33.000Z" itemprop="datePublished">2020-03-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      操作系统
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        
          
<div class="counter-tag counter">
    <span id="/2020/03/16/操作系统/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="操作系统">
         &nbsp;
        view
    </span>
</div>

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h3><ul>
<li><p>操作系统以下是硬件，以上是编译系统等一些支撑软件或者系统使用软件，再往上是实现各个具体应用任务的应用软件。操作系统是最贴近硬件层的系统软件。</p>
</li>
<li><p>操作系统是人机交互的桥梁，为用户提供人机界面，提供便捷、高效的运行环境和服务。</p>
</li>
<li><p>操作系统管理所有硬件资源；控制调度所有程序的运行过程；通过软件的管理方法虚拟地扩充硬件功能</p>
</li>
<li><p>操作系统的概念：一种管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便有效地使用计算机提供良好的运行环境的一种<strong>系统软件</strong></p>
</li>
<li><p>操作系统发展的两大动力：</p>
<ul>
<li>资源的管理需求</li>
<li>用户的使用需求</li>
</ul>
</li>
<li><p>计算机上出现的第一个操作系统：Monitor（单任务操作系统的雏形）</p>
</li>
<li><p>CTSS（Compatible Time-Sharing System）兼容分时系统：将主机连接多个终端，把CPU的处理时间划分了多个时间片，每个时间片处理一个终端上的交互操作。实现多人共享一台计算机资源</p>
</li>
<li><p>UNIX是一个通用的、多用户、多任务的分时操作系统</p>
</li>
<li><p>操作系统在计算机系统中的地位：<br><img src="/Pictures/操作系统在计算机系统中的地位.png" alt="操作系统在计算机系统中的地位"></p>
</li>
<li><p>操作系统的作用<br><img src="/Pictures/操作系统的作用.png" alt="操作系统的作用"></p>
<ul>
<li>为用户提供了实现各种功能的接口</li>
<li>管理系统中所有的资源，硬件和软件，使之能为用户提供更好地服务</li>
<li>在管理和发挥计算机自身的硬件性能的基础上虚拟扩充硬件的功能</li>
<li>控制所有的程序在系统中协调一致地运行</li>
</ul>
</li>
<li><p>操作系统的主要目标</p>
<ul>
<li>方便用户使用</li>
<li>管理系统资源</li>
<li>提高系统效率</li>
<li>扩大机器功能</li>
<li>构筑开放环境</li>
</ul>
</li>
<li><p>操作系统资源管理技术<br><img src="/Pictures/资源管理技术.png" alt="资源管理技术"></p>
<ul>
<li>资源复用：<ul>
<li>空分复用共享：该资源可以进一步分割成更多和更小的单位供进程使用，如内存空间。</li>
<li>时分复用共享：并不把资源进一步分割成更小的单位，进程可以再一个时间段内独占整个屋里资源。如CPU。</li>
</ul>
</li>
<li>资源虚拟<br><img src="/Pictures/资源虚拟.png" alt="资源虚拟"></li>
</ul>
</li>
<li><p>计算机在操作系统的管理下，使得每个用户进程就好像在一台虚拟机上运行一样<br><img src="/Pictures/操作系统虚拟机.png" alt="操作系统虚拟机"></p>
</li>
<li><p>操作系统的资源管理技术<br>对于一类资源，操作系统往往同时实施几种资源管理技术   </p>
<ul>
<li><p>例1：虚拟设备–抽象+虚拟</p>
</li>
<li><p>例2：虚拟主存–复用+虚拟<br>既把内存空间划分为多块实现复用，又通过虚拟扩充技术使得磁盘空间可以虚拟为内存使用</p>
</li>
</ul>
</li>
</ul>
<h3 id="操作系统的处理方式"><a href="#操作系统的处理方式" class="headerlink" title="操作系统的处理方式"></a>操作系统的处理方式</h3><ul>
<li>批处理方式：成批提交成批处理<ul>
<li>接收一批作业到外存，组织成作业流</li>
<li>自动控制一批作业的内存装入和运行过程</li>
<li>全部完成后再将结果反馈给用户</li>
<li>单道批处理方式：一个时间段内，只有一个用户程序在运行<ul>
<li>成批提交</li>
<li>单道装入</li>
<li>顺序运行</li>
</ul>
</li>
<li>多道程序设计技术：是指允许多个程序同时进入一个计算机系统的主存储器并启动进行计算的方法<ul>
<li>成批提交</li>
<li>多道装入</li>
<li>优点：系统系统资源利用率高、系统吞吐量大</li>
<li>缺点：成批处理过程中无交互性（系统自动控制）、用户作业的等待时间长</li>
</ul>
</li>
</ul>
</li>
<li>分时处理方式<ul>
<li>在多道程序设计基础上发展起来的一种处理方式，强调交互性</li>
<li>分时技术：将CPU时间划分为时间片，每个时间片轮流执行用户程序</li>
<li>特征：同时性、交互性、独占性、及时性</li>
</ul>
</li>
<li><p>实时处理方式</p>
<ul>
<li>突出系统处理的即时性或响应性</li>
<li>硬式实时系统，对时间严格约束<ul>
<li>采用专用的管理调度方式</li>
</ul>
</li>
<li>软式实时系统，对时间有限制和要求，但是没有严格的截止时间（deadline）</li>
</ul>
</li>
<li><p>操作系统的功能组成</p>
<ul>
<li>管理对象：<ul>
<li>用户</li>
<li>软硬件资源</li>
</ul>
</li>
<li>管理目标：充分发挥资源小路，甚至虚拟扩充资源的性能，为用户提供最快最好的服务</li>
<li>操作系统的主要管理功能<ul>
<li>用户和接口管理：负责用户身份核实，操作权限管理以及各种人机接口的实现<ul>
<li>用户管理</li>
<li>用户组管理</li>
<li>联机接口管理</li>
<li>脱机接口管理</li>
<li>程序级接口管理</li>
</ul>
</li>
<li>处理机管理（进程管理）：围绕CPU的调度，负责管理、控制用户程序的动态执行过程<ul>
<li>进程控制和管理</li>
<li>进程同步和互斥</li>
<li>进程通信</li>
<li>进程死锁</li>
<li>线程控制和管理</li>
<li>四级调度</li>
</ul>
</li>
<li>存储管理：负责为正在运行的程序分配内存空间，并实现地址和空间有关的管理功能<ul>
<li>内存分配</li>
<li>地址转换</li>
<li>存储保护</li>
<li>内存共享</li>
<li>存储扩充</li>
</ul>
</li>
<li>设备管理：负责外存和I/O设备的分配、驱动和调度控制，以及实现外设读写的相关机制。<ul>
<li>设备的分配和回收</li>
<li>设备的驱动调度</li>
<li>实现罗技设备到物理设备之间的映射</li>
<li>提供设备中断处理</li>
<li>提供缓冲区管理</li>
<li>实现虚拟设备</li>
</ul>
</li>
<li>文件管理：负责建立、存取、目录管理、共享保护以及文件存储空间的管理<ul>
<li>提供文件的逻辑组织方法</li>
<li>提供文件的物理组织方法</li>
<li>提供文件的存取和使用方法</li>
<li>实现文件的目录管理</li>
<li>实现文件的共享和安全性控制</li>
<li>实现文件的存储空间管理</li>
</ul>
</li>
<li>网络与通信管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="操作系统的内核（kernel）"><a href="#操作系统的内核（kernel）" class="headerlink" title="操作系统的内核（kernel）"></a>操作系统的内核（kernel）</h3><p>内核是作为可信软件来提供支持进程并发执行的基本功能和基本操作的一组程序（内核程序）。如时钟管理、CPU调度、内存分配等。在开机时，内核程序一定会装入内存中的内核空间中，运行于CPU的核心态下，具有访问硬件设备和所有主存空间的权限。</p>
<ul>
<li>内核的属性<ul>
<li>中断驱动</li>
<li>不可抢占</li>
<li>可以再屏蔽中断状态下执行</li>
<li>可以使用特权指令</li>
</ul>
</li>
<li>内核分类：<ul>
<li>单内核：Linux<br><img src="/Pictures/LInux单体式单内核结构.png" alt="单内核"></li>
<li>微内核<br><img src="/Pictures/微内核操作系统.png" alt="微内核"></li>
</ul>
</li>
<li>PC机DOS操作系统启动过程<br><img src="/Pictures/PC机开机过程.png" alt="启动过程">    <img src="/Pictures/PC机开机过程2.png" alt="启动过程">  </li>
</ul>
<h3 id="操作系统的主要特征"><a href="#操作系统的主要特征" class="headerlink" title="操作系统的主要特征"></a>操作系统的主要特征</h3><ul>
<li><p>并发性：在一个时间段内，多个程序处于宏观的运行状态，并发推进。让有限的物理资源实现多用户共享，一提高效率<br><img src="/Pictures/串并发.png" alt="串并并发"> </p>
<p>优点：</p>
<ul>
<li>一个时间段内，多个程序（进程）共享系统资源</li>
<li>发挥并发性能够消除系统中部件和部件之间的相互等待，有效的改善系统资源的利用率</li>
</ul>
<p>进程并发必须解决的问题：<br><img src="/Pictures/进程并发必须解决的问题.png" alt="进程并发必须解决的问题"></p>
<p>并发的实质是一个物理COU（也可以多个）在若干道程序之间的多路复用</p>
</li>
<li>共享性：操作系统中的资源可以被多个并发执行的进程所使用<ul>
<li>同时共享：同时具有使用权。涉及透明资源共享（资源隔离与授权访问）</li>
<li>互斥共享：轮流使用。涉及显式资源共享（临界资源与独占访问）</li>
</ul>
</li>
<li><p>异步性<br><img src="/Pictures/异步性.png" alt="异步性"> </p>
<p>异步性给系统带来潜在的危险，有可能导致<strong>与时间有关的错误</strong><br>面对异步性系统，操作系统的一个重要的任务是必须确保捕捉任何一种随机事件，正确处理，否则将会导致严重后果。</p>
</li>
<li>虚拟性：利用某种技术奖少的物理资源演变为多的、逻辑上的对应资源；还包括将慢的虚拟成快的、容量小的虚拟成容量大的、不能共享的虚拟成能共享的，等。</li>
</ul>
<h2 id="作业管理模块"><a href="#作业管理模块" class="headerlink" title="作业管理模块"></a>作业管理模块</h2><ul>
<li><p>概念：</p>
<ul>
<li>作业管理模块是操作系统中最外层的直接面对用户的模块</li>
<li>为用户提供系统接口，将用户需求提交系统，再将处理结果反馈用户</li>
<li>负责用户管理，核准用户合法性，管理用户使用资源及费用等情况</li>
</ul>
</li>
<li><p>作业：用户提交给计算机系统的任务</p>
<ul>
<li>程序： 完成任务所要执行的代码</li>
<li>数据： 代码执行过程处理的数据</li>
</ul>
</li>
<li><p>作业的不同类别</p>
<ul>
<li>批处理型作业：批处理方式提交的作业<br><img src="/Pictures/批处理作业.png" alt="批处理型作业"></li>
<li>交互型作业：以交互方式提交的作业<br><img src="/Pictures/交互型作业.png" alt="交互型作业"></li>
<li>实时型作业：特指相应时间有实时需求的作业<br><img src="/Pictures/实时型作业.png" alt="实时型作业"><ul>
<li>硬实时作业：有严格的响应时间的控制，不在某个时间点相应的话，效益为零</li>
<li>软实时作业：按要求的相应时间相应效益最佳，但不会直接降为零<br><img src="/Pictures/硬实时软实时.png" alt="硬实时软实时"> </li>
</ul>
</li>
<li>不同作业类别的管理、调度方式不同<br><img src="/Pictures/作业类别.png" alt="作业类别"></li>
</ul>
</li>
<li><p>作业管理模块的功能</p>
<ul>
<li><p>用户管理</p>
<ul>
<li>新建用户</li>
<li>删除用户</li>
<li>验证身份</li>
<li>维护用户信息</li>
<li>配置用户运行环境</li>
<li>设置用户权限</li>
<li>用户组的设置与管理</li>
<li>用途：方便计费，方便系统安全管理</li>
</ul>
</li>
<li><p>接口管理</p>
<ul>
<li>操作员接口 || 程序员接口</li>
<li>联机接口 || 脱机接口</li>
</ul>
</li>
<li><p>批作业的管理控制与调度</p>
<ul>
<li>作业状态</li>
<li>作业控制块</li>
<li>作业调度</li>
<li>作业的装载与卸出</li>
<li>将批作业收容到外存的“作业输入井”中，建立“作业控制块”记录作业控制信息，通过作业调度选择后背作业装载内存，并在作业完成后将作业卸出</li>
</ul>
</li>
</ul>
</li>
<li><p>作业的管理控制</p>
<ul>
<li><p>批作业的状态管理：批作业的每个运行阶段用一个状态来描述，不同的运行阶段通过状态之间的转换来进行控制</p>
</li>
<li><p>批作业控制块（JCB）：记录作业的各项属性和管理信息。内容包括：</p>
<ul>
<li>作业号</li>
<li>作业类别</li>
<li>用户名及用户账号</li>
<li>作业状态</li>
<li>提交到系统的时间</li>
<li>优先级（响应比）</li>
<li>作业所在的外存位置</li>
<li>资源需求</li>
<li>运行长度</li>
<li>运行的时间</li>
<li>其它信息（收费标准，JCB队列指针等）</li>
</ul>
</li>
<li><p>不同作业I/O方式</p>
<ul>
<li>联机I/O：主机连接I/O设备，在作业运行过程中，占用着CPU进行输入和输出过程。缺点：快速的CPU等待满速的I/O设备</li>
<li>脱机I/O：将I/O操作与主机运行相脱离，单独设置专用的输入输出计算机</li>
<li>假脱机方式（现代操作系统）：又称为“在线外设并行访问”，简记为Spooling。在这种方式中，不再单独设置专用的输入输出计算机，而是将输入输出功能从操作系统内核中分离出来，单独形成I/O进程，来完成用户的输入输出工作<br><img src="/Pictures/假脱机.png" alt="假脱机"> </li>
</ul>
</li>
<li><p>不同作业控制方式 </p>
</li>
</ul>
<p>操作系统必须对用户作业的全过程实施控制，包括，怎样将作业输入到计算机中去、怎样控制作业的运行、运行出现故障后如何进行处理、作业运行结束后输出哪些内容</p>
<ul>
<li>脱机作业控制：一般适用于批处理系统中，所有作业的控制信息都由用户按照系统提供的作业控制语言来编制。用户提交作业之后，作业的运行完全脱离用户的干预。</li>
<li>联机作业控制：大多数分时系统和实时系统采用的一种作业控制方式，整个控制过程由用户使用操作系统提供的操作命令，与计算机通过交互会话方式来控制作业执行</li>
<li>批作业与交互作业控制方式的不同<br><img src="/Pictures/批作业与交互作业控制方式的不同.png" alt="批作业与交互作业控制方式的不同"> </li>
</ul>
</li>
</ul>
<ul>
<li>批作业的状态<ul>
<li>“后备状态”：已经提交到外存的“作业收容井”，等待调度装入</li>
<li>“驻留状态”（运行状态）：被作业调度选中，已经装入内存，处于宏观的运行状态</li>
<li>“完成状态”：作业相关代码已经执行结束，已不再占用内存空间和系统各种设备，正在等待卸出和数据缓输出<br><img src="/Pictures/作业转换图.png" alt="作业转换图">  </li>
</ul>
</li>
</ul>
<h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2><p>  <img src="/Pictures/操作系统接口.png" alt="操作系统接口"> </p>
<ul>
<li>脱机命令接口———作业的控制说明语言<ul>
<li>批处理系统中，用户提交给系统的一个计算任务就是一个作业</li>
<li>批作业 = 程序 + 数据 + 作业控制说明书</li>
<li>作业控制说明书由作业控制语言编写，也就是由一条条控制作业如何运行的命令组成。是计算机系统给批用户提供的一个接口</li>
<li>作业控制说明语言是由一组作业控制命令组成的集合，专门用于批处理系统</li>
</ul>
</li>
<li><p>联机命令接口（人机交互方式）</p>
<ul>
<li>命令行方式操作接口（键盘命令）</li>
<li>图形化界面（鼠标点击）</li>
<li>涉及的服务程序：<ul>
<li>终端处理程序</li>
<li>命令解释程序</li>
<li>鼠标点击事件响应程序</li>
</ul>
</li>
</ul>
</li>
<li><p>程序级接口———系统调用</p>
<ul>
<li>一种适用于应用程序中的功能调用接口，允许用户在自己的应用程序中调用系统提供的一些功能模块。即应用程序调用系统程序</li>
<li>系统调用时应用程序获得操作系统服务的唯一途径<br><img src="/Pictures/系统调用.png" alt="系统调用"><br><img src="/Pictures/系统调用的服务例程.png" alt="系统调用的服务例程"></li>
<li>CPU的两种工作状态<ul>
<li>管态（系统态）：执行系统程序的状态，允许执行所有指令</li>
<li>目态（用户态）：执行用户程序的状态，只允许执行非特权指令<br><img src="/Pictures/系统调用的前后.png" alt="系统调用的前后"></li>
</ul>
</li>
<li>系统调用分类<ul>
<li>进程和作业管理类</li>
<li>文件操作类</li>
<li>设备管理类</li>
<li>主存管理类</li>
<li>信息维护类</li>
<li>通信类</li>
</ul>
</li>
<li>系统调用与API函数的区别<ul>
<li>系统调用：程序级接口，通过该接口用户可以调用操作系统提供的功能模块（以函数形式提供）。系统调用的服务例程在<strong>管态</strong>下执行，</li>
<li>API：系统提供的应用函数库，也称应用程序接口，将一些常用的功能函数事先实现，供用户程序直接调用，其中一些API函数的实现过程调用了一个或几个系统调用。API函数在<strong>目态</strong>下执行。</li>
</ul>
</li>
<li>Linux系统程序、程序调用、库函数、应用程序分层关系<br><img src="/Pictures/分层关系.png" alt="分层关系"></li>
<li>系统调用的实现过程<ul>
<li>为系统调用编写处理内核函数   </li>
<li>设计一张系统调用入口地址表，每个入口地址都指向一个系统调用的内核函数，有的系统还包含系统调用自带参数的个数。</li>
<li>陷入处理机制：中断要进行系统调用的用户进程，开辟现场保护区，将被中断进程的现场信息存储到保护区内，以保存发生系统调用时的处理器现场。</li>
</ul>
</li>
<li>系统调用的处理过程<br><img src="/Pictures/系统调用的处理过程.png" alt="系统调用的处理过程"></li>
</ul>
</li>
</ul>
<h2 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h2><ul>
<li>作业调度又称“高级调度”：<ul>
<li>是批处理系统中采用的一级调度。</li>
<li>主要功能是，从处于后备状态的作业中按照某种算法选择一道或者几道作业装入内存，被选中的作业就从收容或者后备状态转入到驻留状态。</li>
<li>作业调度解决的是作业与作业之间的自动转接问题，即免去作业控制中的人工操作问题</li>
</ul>
</li>
<li>作业调度算法：<br><img src="/Pictures/作业调度算法.png" alt="作业调度算法"><ul>
<li>FCFS(First Come First Served)<ul>
<li>选择最先进入后备队列的作业装入内存</li>
<li>优点：容易实现</li>
<li>缺点：<br>不分作业长短，对短小作业十分不利；<br>不顾轻重缓急；<br>对时间要求紧迫的作业不能做到急事急办</li>
</ul>
</li>
<li>SJF(Shortest Job First)<ul>
<li>从后备作业中选择运行时间最短的作业装入内存</li>
<li>优点：照顾短作业用户的利益，提高系统吞吐量，让作业的<strong>平均周转时间</strong>降下来</li>
<li>缺点：推迟长作业的运行，可能出现饥饿现象。  <pre><code>估计运行时间本身有可能不太准确
</code></pre></li>
</ul>
</li>
<li>HRF<ul>
<li><img src="/Pictures/HRF.png" alt="HRF"> </li>
<li>优点：折中考虑到作业进入系统的先后次序，又顾及到作业的运行时间</li>
<li>缺点：每次调度都要计算每个作业的相应比，开销大</li>
</ul>
</li>
<li>HPF(Highest Response First)优先级调度算法<ul>
<li>每次总是选择后备作业中优先级最高的作业装入内存</li>
<li>当一个作业进入系统，系统根据多方面因素（用户级别、用户租金、作业类别等）会为作业赋予一个优先级</li>
<li>比较灵活，优先级可以根据需要灵活确定</li>
<li>经常作为基于<strong>作业运行紧迫性</strong>的一种调度方案</li>
</ul>
</li>
<li>均衡调度算法<br><img src="/Pictures/均衡调度算法.png" alt="均衡调度算法"><ul>
<li>根据内存容量的限制，选择一组资源互补型的作业装入</li>
<li>目的：在作业运行期间，尽可能提高CPU和各种设备之间的并行度，从而提高整个系统的效率</li>
</ul>
</li>
</ul>
</li>
<li>作业调度性能的衡量准则<ul>
<li>系统吞吐量<br><img src="/Pictures/系统吞吐量.png" alt="系统吞吐量"><br>平均周转时间：<br><img src="/Pictures/平均周转时间.png" alt="平均周转时间"></li>
<li>对短作业优惠<ul>
<li>主要为了吸引中小用户使用计算机</li>
<li>为了描述系统对短小作业的优惠程度，可以用作业的平均带权周转时间W作为评价参数   </li>
<li>定义：平均带权周转时间<br><img src="/Picture/平均带权周转时间.png" alt="平均带权周转时间"></li>
</ul>
</li>
<li>其他指标<br><img src="/Pictures/其他指标.png" alt="其他指标"> </li>
</ul>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程的表述：进程是一个程序的一次动态执行过程</p>
<ul>
<li>一个正在计算机上执行的程序</li>
<li>一个能分配给处理器执行的实体</li>
<li>一个具有一下特征的活动单元：一组指令序列的执行、一个当前状态和相关的系统资源集</li>
</ul>
<p>进程的重要性：</p>
<ul>
<li>是操作系统最核心的概念之一</li>
<li>是操作系统要面对的最核心的管理对象</li>
<li>是占用CPU资源和其它资源的实体</li>
<li>用户的所有程序均通过进程(用户进程)的形式运行</li>
<li>操作系统给用户提供的各种服务也是以进程(系统进程)的形式运行</li>
<li>进程管理模块是操作系统最核心的一个模块</li>
<li>学习操作系统内核从学习操作系统如何建立、管理、调度进程开始</li>
</ul>
<p>引进进程对操作系统的作用:</p>
<ul>
<li>使用进程描述每一个程序的每一次动态执行</li>
<li>通过进程实体来管理控制每一个程序的每一次执行过程</li>
<li>操作系统引进“子进程”，使大程序的程序段可以并发，以加快程序推进并且提高CPU利用率</li>
</ul>
<p>现代操作系统是多道程序设计系统：多道程序并发运行，共享(竞争) CPU、内存I/O设备等资源。</p>
<p>并发运行方式的基本特征：</p>
<ul>
<li>异步</li>
<li>资源共享</li>
<li>相互制约</li>
<li>不可重现: 进程执行的结果不可重现</li>
</ul>
<p>进程与程序的区别</p>
<ul>
<li>程序是完成一项任务的代码序列</li>
<li>进程是一个程序的一次动态执行过程</li>
<li>程序是静态的; 进程是动态的</li>
<li>程序只包含代码; 进程包括要运行的代码、代码要处理的数据、运行过程中的参数等</li>
</ul>
<p>进程与程序的关联</p>
<ul>
<li>进程是操作系统为了管理控制程序的运行而加设的一个概念和实体</li>
<li>程序不运行就没有进程； 一个进程是一个程序的一次执行过程</li>
<li>一个程序可能对应多个进程<br><img src="/Pictures/作业程序进程.png" alt="作业程序进程"></li>
</ul>
<p>进程的特征</p>
<ul>
<li>动态特征：生命周期</li>
<li>并发特征：在一个时间段内都处在宏观的运行状态</li>
<li>独立特征：独立占有资源、独立参与CPU调度</li>
<li>异步特征：运行推进速度不可预知</li>
<li><p>结构特征：PCB(Process Contorl Block进程控制块)+进程体<br><img src="/Prictures/进程的组成.png" alt="进程的组成"></p>
<ul>
<li><p>进程控制块PCB的内容：<br><img src="/Pictures/进程控制块.png" alt="进程控制块"><br>进程控制块通常为结构体类型，包含进程的属性</p>
<ul>
<li>进程标识：系统识别进程的标志<ul>
<li>外部标识：进程的创建者提供的进程名字，通常由字符串组成</li>
<li>内部标识(PID)：系统为进程命名的一个代码，通常是一个整数</li>
</ul>
</li>
<li>进程调度信息：系统调度选择进程的依据<ul>
<li>进程优先数：描述进程紧迫性</li>
<li>进程状态信息：描述进程当前状态</li>
<li>其它调度信息：如：进程在系统中等待的时间、已在CPU上运行的时间、剩余的运行时间</li>
</ul>
</li>
<li><p>处理机信息(进程上下文) </p>
<p>进程被中断时，该进程的CPU现场信息可以保存在它自己的PCB内，以便该进程重新获得CPU时可以从此处回复现场信息，继续运行。 </p>
<ul>
<li>通用寄存器的内存：包括数据寄存器、段寄存器</li>
<li>程序状态字PSW(Program Status Word)的值</li>
<li>程序计数器PC(Program Count)的值</li>
<li>程序的堆栈指针</li>
</ul>
</li>
<li>进程控制信息：系统对进程实施控制的依据<ul>
<li>程序代码和数据集所在的内存地址</li>
<li>资源清单，记载进程请求资源和已经占有资源的情况</li>
<li>同步通信信息</li>
<li>外存地址</li>
<li>家族信息：父子进程</li>
<li>链接指针：跟当前PCB链接在同一队列的下一个PCB的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>进程管理模块的主要功能</p>
<ul>
<li>进程控制<ul>
<li>管理控制一个进程的生命周期<ul>
<li>创建新进程，撤销结束进程</li>
<li>阻塞或唤醒进程</li>
<li>挂起或激活进程</li>
</ul>
</li>
<li>管理控制多个进程的并发<ul>
<li>进程同步和进程互斥</li>
<li>进程通信 </li>
</ul>
</li>
</ul>
</li>
<li>进程调度<ul>
<li>根据进程当前状态决定哪个进程获得CPU，以及占用多长时间</li>
<li>将CPU分给进程 </li>
</ul>
</li>
</ul>
<h2 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h2><p>系统的状态被管理为两种形式：运行态与非运行态，运行态为进程占用CPU时候的状态，其它情况下的进程都为非运行态<br><img src="/Pictures/两状态进程模型.png" alt="两状态进程模型"><br><img src="/Pictures/队列轮转图.png" alt="队列轮转图"></p>
<p>进程的三种基本状态：</p>
<ul>
<li>运行状态，进程获得CPU并投入运行的一种状态。在单CPU系统中，每个瞬间最多只能有一个进程在运行</li>
<li>就绪状态，进程尚未获得CPU使用权的一种状态。进程已经拥有除CPU外其它全部所需资源</li>
<li>阻塞状态，进程因为某种要求得不到满足，只好等待，称为运行受阻。处于阻塞状态的进程不配获得CPU<br><img src="/Pictures/三状态基本模型.png" alt="三状态基本模型"><br>进程的生存空间为作业驻留状态<br><img src="/Pictures/状态转换.png" alt="状态转换"></li>
<li><p>两种扩展的挂起状态</p>
<p>挂起：将内存中当前某个尚不能运行的进程调到外存上，腾出来空间接纳更多的进程。这一处理称为进程挂起(Suspend)。<br>挂起某些暂时不能运行的进程，目的是腾出内存装入更多进程，使CPU忙碌起来</p>
<ul>
<li>挂起阻塞状态(S-Blocked)</li>
<li>挂起就绪状态(S-Ready)<br><img src="/Pictures/一个挂起状态.png" alt="一个挂起状态"><br><img src="/Pictures/两个挂起状态.png" alt="两个挂起状态"></li>
</ul>
</li>
<li>PCB队列结构<br>  <img src="/Pictures/PCB队列结构.png" alt="PCB队列结构"> </li>
</ul>
<h3 id="进程状态转换原语"><a href="#进程状态转换原语" class="headerlink" title="进程状态转换原语"></a>进程状态转换原语</h3><ul>
<li>进程从残生到消亡的整个过程中都是有操作系统来控制的。</li>
<li>操作系统中实现进程控制的功能程序称为“原语”：机器指令构成的一种实现特定功能的小程序，它的运行具有不可分割性。<ul>
<li>贴近底层</li>
<li>最重要的</li>
<li>运行过程具有原子性（不可中断）</li>
<li>系统小程序 </li>
</ul>
</li>
<li>操作系统中的原语类别<br><img src="/Pictures/进程控制原语.png" alt="进程控制原语"><br><img src="/Pictures/原语类别.png" alt="原语类别"><h3 id="创建与撤销原语"><a href="#创建与撤销原语" class="headerlink" title="创建与撤销原语"></a>创建与撤销原语</h3></li>
<li>进程创建原语<ul>
<li>何时运行<br><img src="/Pictures/创建原语运行.png" alt="创建原语运行"></li>
<li>如何运行<br><img src="/Pictures/如何运行.png" alt="如何运行"><br><img src="/Pictures/创建原语2.png" alt="创建原语2"><br><img src="/Pictures/创建原语3.png" alt="创建原语3"><br><img src="/Pictures/创建原语4.png" alt="创建原语4"></li>
</ul>
</li>
<li>进程撤销原语<ul>
<li>何时运行<br><img src="/Pictures/何时撤销.png" alt="何时撤销"> </li>
<li>如何运行<br><img src="/Pictures/撤销运行.png" alt="撤销运行"><br><img src="/Pictures/撤销原语2.png" alt="撤销原语2"><br><img src="/Pictures/撤销原语3.png" alt="撤销原语3"><h3 id="阻塞与唤醒原语"><a href="#阻塞与唤醒原语" class="headerlink" title="阻塞与唤醒原语"></a>阻塞与唤醒原语</h3></li>
</ul>
</li>
<li>阻塞原语<ul>
<li>何时运行<ul>
<li>当正在运行的程序需要等待某一事件而发生运行受阻时，它通过中断请求系统服务</li>
<li>系统按照进程的需求进行适当处理后，启动“进程阻塞原语”将该进程阻塞起来 </li>
<li>引起进程阻塞的原因<ul>
<li>等待I/O</li>
<li>请求资源得不到满足</li>
<li>进程同步约束</li>
<li>服务进程无事可做 </li>
</ul>
</li>
</ul>
</li>
<li>如何运行<br><img src="/Pictures/阻塞原语的运行.png" alt="阻塞原语的运行"> </li>
</ul>
</li>
<li>唤醒原语<ul>
<li>何时运行<ul>
<li>当系统发生某一个事件时，正在等待该事件的进程需要立即被唤醒，由“阻塞”状态转为就绪状态</li>
<li>进程被唤醒的原因<ul>
<li>所等待的I/O操作已完成</li>
<li>请求的资源得到了满足</li>
<li>进程同步约束已撤销</li>
<li>服务进程收到新的任务  </li>
</ul>
</li>
</ul>
</li>
<li>如何运行–唤醒原语Wake_up()<ul>
<li>将当前进程的上下文保存到系统栈中（让现在正在占用CPU的当前进程暂时停下来）</li>
<li>从阻塞队列上查找等待该时间的进程PCB</li>
<li>将PCB从阻塞队列上摘下来</li>
<li>将其状态设置为“就绪”，将PCB挂入就绪队列</li>
<li>弹出系统栈中的进程上下文，置入CPU，让被中断的进程恢复运行</li>
<li>结束<h3 id="挂起与激活原语"><a href="#挂起与激活原语" class="headerlink" title="挂起与激活原语"></a>挂起与激活原语</h3></li>
</ul>
</li>
</ul>
</li>
<li>挂起原语<ul>
<li>何时运行<ul>
<li>当内存空间紧缺，部分进程有限运行</li>
<li>应用户的要求，将用户进程挂起</li>
<li>应父进程的要求，将子进程挂起</li>
</ul>
</li>
<li>如何运行–挂起原语Suspend()<ul>
<li>找到被挂起进程的PCB，获得其内存地址，将内控空间归还给存储管理模块</li>
<li>进程状态，阻塞转为“挂起阻塞”，或者就绪转为“挂起就绪”，将PCB从原队列转入相应的挂起队列</li>
<li>申请外存交换区空间，换出进程，将外存交换区所在的地址写入PCB</li>
<li>结束</li>
</ul>
</li>
</ul>
</li>
<li>激活原语<ul>
<li>何时运行<ul>
<li>有进程运行完毕，当前内存空间并不紧张</li>
<li>应用户要求，将其进程激活</li>
<li>应父进程的要求，将其子进程激活</li>
<li>进程自身设定的挂起周期已完成</li>
</ul>
</li>
<li>如何运行–激活原语Active()<ul>
<li>扫描“挂起就绪队列”（优先扫描挂起就绪队列，也可以扫描阻塞队列）也找到被激活进程的PCB</li>
<li>将PCB从所在的队列上摘下来</li>
<li>按PCB登记的时间需求，申请内存，加载到内存中</li>
<li>归还外存交换区空间</li>
<li>将进程状态置为“就绪”，插入就绪队列</li>
<li>结束</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="父进程与子进程"><a href="#父进程与子进程" class="headerlink" title="父进程与子进程"></a>父进程与子进程</h2><ul>
<li>fork()函数<br><img src="/Pictures/fork函数.png" alt="fork函数"><br><img src="/Pictures/fork返回值.png" alt="fork返回值"><br><img src="/Pictures/fork失败返回.png" alt="fork失败返回"><br><img src="/Pictures/测试fork返回值.png" alt="测试fork返回值"></li>
<li>提醒<ul>
<li>UNIX中，父进程通过系统调用fork()创建子进程，子进程继承父进程资源，父子进程各自独立</li>
<li>父子进程各自拥有自己的PCB、内存用户区、临时资源等，各自独立参与CPU调度，即父子进程的运行是异步的 </li>
</ul>
</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ul>
<li>进程调度功能：从处于就绪状态的进程中，按照某种调度策略，选择一个进程切换给CPU，使其状态从就绪转为运行</li>
<li>调度方式<ul>
<li>非抢占式调度：当前进程主动放弃CPU的使用权<ul>
<li>进程运行完毕退出</li>
<li>运行受阻</li>
<li>运行出错，非正常终止</li>
<li>遇到不可挽回的故障</li>
</ul>
</li>
<li>抢占式调度<ul>
<li>也称剥夺式调度，一般用于有实时需求的系统。</li>
<li>主要指在系统正常运行期间，如果某种事件出现，系统将<strong>迫使正在运行的进程停下来</strong>，将CPU控制权交给其它进程。</li>
<li>其思想源自对高紧迫度作业的相应。</li>
</ul>
</li>
</ul>
</li>
<li>调度策略（调度算法）<ul>
<li>FCFS(First Come First Served)算法，先来先服务。先进入就绪队列的进程先调度</li>
<li>SPF(Shortest Process First)算法，短进程优先调度</li>
<li>HPF(Highest Priority First)算法，最高优先级调度</li>
<li>HRF(Highest Response First)算法，高响应比优先调度。</li>
<li>STR(Shortest Remain Time)算法，最短剩余时间优先算法。通常使用与实时系统中对于周期任务的调度</li>
<li>RR（Round Robin)算法，时间片轮转调度算法：<ul>
<li>将CPU的使用时间划分为多个时间片，各个并发进程轮流使用CPU，各使用一个时间片，时间片用完管理程序停止它的运行，并将它转入就绪队列尾部，调用下一个进程</li>
<li>应用于分时系统，目标是提高响应及时性</li>
<li>启动时机：<ul>
<li>一个时间片运行结束</li>
<li>当前进程运行结束</li>
<li>正在运行的进程因运行受阻主动放弃了CPU控制权</li>
</ul>
</li>
<li>时间片的选取<ul>
<li>进程的道数较多时，q就选得小一些；反之，可选得大些</li>
<li>系统要求的响应时间比较苛刻的时候，q就选得小一些，反之，可选得大一些。</li>
</ul>
</li>
</ul>
</li>
<li>多级队列调度算法<ul>
<li>设置多个就绪队列</li>
<li>就绪队列优先级不同，优先级高的队列优先调度</li>
<li>优先级高的队列空时，再调度低优先队列</li>
</ul>
</li>
<li>多级队列反馈调度算法<br><img src="/Pictures/多级队列反馈调度算法1.png" alt="多级队列反馈调度算法"><br><img src="/Pictures/多级队列反馈调度算法2.png" alt="多级队列反馈调度算法"><br>既照顾到短的进程，又照顾到长的进程，是一种性能比较好的进程调度算法</li>
</ul>
</li>
</ul>
<h2 id="实时系统的任务调度"><a href="#实时系统的任务调度" class="headerlink" title="实时系统的任务调度"></a>实时系统的任务调度</h2><ul>
<li><strong>实时任务</strong>是一类对时间要求较为严格的进程。支持这类任务运行的系统称为<strong>实时处理系统</strong>，分<strong>硬实时系统</strong>和<strong>软实时系统</strong></li>
<li>实时系统的调度方式一般是剥夺式（抢占式）的</li>
<li>非周期实时任务：不确定产生和停止的时间<ul>
<li>紧迫型：多见于专用的、响应时间要求特别苛刻的数据采集和控制系统中，所要求的相应时间一般是微秒级的。采用“<strong>立即抢占调度算法</strong>（HPF）。<br><img src="/Pictures/立即抢占.png" alt="立即抢占"> </li>
<li>普通型：对相应时间的要求不是太高，一般是毫秒级的。由于它允许相应时间长度与时钟中断的周期基本吻合，一般采用“<strong>基于时钟中断抢占的高优先级调度算法</strong>”<br><img src="/Pictures/基于时钟中断抢占.png" alt="基于时钟中断抢占"> </li>
<li>宽松型：要求的响应时间比较长，一般可达数百毫秒甚至数秒钟。采用的调度算法也有多种：<ul>
<li>非抢占的优先级调度算法（HPF）<br><img src="/Pictures/非抢占的优先级调度算法.png" alt="非抢占的优先级调度算法"> </li>
<li>时间片轮转算法（RR）<br><img src="/Pictures/时间片轮转算法.png" alt="时间片轮转算法"> </li>
</ul>
</li>
</ul>
</li>
<li>周期实时任务：信号检测和过程控制系统中呈现周期性运行规律的任务<br><img src="/Pictures/周期性实时任务.png" alt="周期性实时任务"><ul>
<li>最小剩余时间调度算法（SRT）</li>
</ul>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>一个进程运行过程中可创建多个线程，线程共享所属进程的资源，自己只有线程控制块（TCB）和很少的栈区</p>
<ul>
<li>线程的描述：<ul>
<li>线程是现代操作系统引入的一种执行实体</li>
<li>线程称“轻型进程”，是进程的组成成分</li>
<li>进程是资源占有单位，线程只是CPU调度单位，即执行单位</li>
</ul>
</li>
<li>多线程进程模型<br><img src="/Pictures/多线程进程模型.png" alt="多线程进程模型"></li>
<li>多线程结构进程的优点<ul>
<li>快速线程切换</li>
<li>通信易于实现</li>
<li>减少管理开销</li>
<li>并发程度提高</li>
</ul>
</li>
<li>线程的分类：内核级线程KTL和应用级线程UTL<br><img src="/Pictures/线程的分类.png" alt="线程的分类"> <ul>
<li>KTL:由操作系统的系统程序创建，系统可见。管理、控制、调度都是由操作系统完成</li>
<li>UTL：由用户程序创建、管理、调度，用户可见。</li>
</ul>
</li>
<li>进程与线程的区别<ul>
<li>进程是一个独立的实体单位：<ul>
<li>独占资源</li>
<li>独立参与调度/执行</li>
</ul>
</li>
<li>线程仅是分派（调度运行）的单位</li>
<li>线程不是单独占有资源的单位。线程共享其所属进程的资源</li>
<li>操作系统<strong>引入进程</strong>的目的是为了多个程序并发执行，以改善资源使用率和提高系统效率</li>
<li>操作系统<strong>引入线程</strong>的目的是为了减少并发执行时所付出的时空开销，是的并发粒度更细、并发性更好 </li>
</ul>
</li>
</ul>
<h2 id="处理机的四级调度"><a href="#处理机的四级调度" class="headerlink" title="处理机的四级调度"></a>处理机的四级调度</h2><ul>
<li>调度的主要目标：选择哪个实体进入内存、选择哪个实体占用CPU</li>
<li>调度的主要层次：作业调度、进程调度、中级调度、线程调度</li>
<li>三级调度：<ul>
<li>高级调度：又称作业调度、长程调度。从处于后备状态的作业中选择一道或几道，装入内存。只有批作业会进入高级调度</li>
<li>中级调度：又称中程调度。优先从处于挂起就绪状态的进程中选择一个或几个，将其激活</li>
<li>低级调度：又称进程调度、短程调度。从处于就绪状态的进程中选择一个，切换给CPU执行<br><img src="/Pictures/三级调度.png" alt="三级调度"> </li>
</ul>
</li>
<li>四级调度：在三级调度的基础上加了进程调度<ul>
<li>用户级线程的调度<br><img src="/Pictures/用户级线程调度.png" alt="用户级线程调度"> <ul>
<li>操作系统进行进程调度</li>
<li>用户程序进行线程调度</li>
</ul>
</li>
<li>内核级线程的调度<br><img src="/Pictures/内核级线程调度.png" alt="内核级线程调度"><br>操作系统直接进程线程调度</li>
</ul>
</li>
<li>线程与子进程调度的区别<br><img src="/Pictures/线程与子进程调度的区别.png" alt="线程与子进程调度的区别"> </li>
</ul>
<h2 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h2><ul>
<li>互斥：允许多个进程共享资源，但是多个进程不能同时获取和使用资源。体现进程之间的竞争关系</li>
<li>同步：允许多个进程共享资源，但是多个进程不能同时使用，而且使用顺序也有严格的约束</li>
<li>并发：<ul>
<li>单处理器多道程序设计中，多个进程交替执行</li>
<li>多个并发进程在一个时间段内都处于运行状态</li>
<li>共享系统资源</li>
<li>每个进程都“走走停停”</li>
<li>并发带来异步性：每个进程在某一时刻的运行状态都不确定</li>
</ul>
</li>
<li>并发带来的问题<ul>
<li>并发进程的相对执行速度不可预测</li>
<li>可能会发生各种与时间有关的错误</li>
</ul>
</li>
<li>临界资源（Critical Resources）：也叫互斥资源，一次只能为一个进程服务的共享资源。<ul>
<li>临界区：进程体重使用临界资源的代码段</li>
<li>相关临界区：使用同一临界资源的的不同的代码段</li>
</ul>
</li>
<li>与并发相关的关键术语<ul>
<li>互斥：当一个进程在进阶区进行时，使用临界资源，其它进程不能进入相关临界区。体现竞争关系</li>
<li>同步：不但不能同时使用临界资源，还得有严格的先后使用顺序。体现协作关系</li>
<li>死锁：两个或两个以上的进程，因为其中的每个进程都在等待其它进程做完某些事情，而整体不能继续执行，所有进程永远阻塞等待</li>
<li>活锁：两个或两个以上的进程，为了响应其它进程中的变化而持续改变自己的状态，但不做有用的工作</li>
<li>饥饿：一个可运行的进程被调度程序无限地忽略，不能被调度的情形</li>
<li>原子操作：保证指令序列要么作为一个组来执行，要么都不执行</li>
</ul>
</li>
<li>操作系统在管理和控制资源分配方面，应当保证进程对临界资源的访问满足：<ul>
<li>互斥访问</li>
<li>不至于产生“死锁”</li>
<li>不能有“饥饿”进程</li>
</ul>
</li>
</ul>
<h2 id="解决进程互斥"><a href="#解决进程互斥" class="headerlink" title="解决进程互斥"></a>解决进程互斥</h2><ul>
<li>互斥管理准则<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
</li>
<li>软件方法解决进程互斥：实际上是失败的，现代操作系统中不再使用</li>
<li>信号量机制解决进程互斥<ul>
<li>基本原理：<ul>
<li>两个或多个进程通过简单的信号进行合作</li>
<li>任何复杂的合作需求都可以通过适当的信号结构得到满足</li>
</ul>
</li>
<li>实现要素<ul>
<li>信号量（Semaphore结构体类型，内含一个阻塞队列和一个整型值）</li>
<li>P操作原语（wait）：执行进程进入临界区之前的检查操作</li>
<li>V操作原语（signal）：进程出临界区时释放资源</li>
</ul>
</li>
<li>解决互斥<ul>
<li>一种CR设一个信号量，根据临界资源的种类来设置</li>
<li>信号量的初值设置为<strong>系统初始状态CR允许几个进程使用</strong></li>
<li>P操作用于临界区前，相当于进入CS之前申请CR</li>
<li>V操作用于临界区前，相当于出之后释放CR</li>
<li>P、V操作必须成对匹配</li>
</ul>
</li>
<li>互斥信号量的值(semaphore mutex: value)：<ul>
<li>>= 1 目前临界资源有mutex.value个可用</li>
<li>== 0 目前临界资源没有可用的</li>
<li>&lt;= 0 目前有|mutex.value|个进程因等待该临界资源而阻塞</li>
</ul>
</li>
<li>解决同步<ul>
<li>一种CR设一个信号量，根据需要的同步信号来设置</li>
<li>信号量的初值设置为<strong>系统初始状态下信号的有无</strong></li>
<li>P操作用于临界区前，相当于检查同步信号</li>
<li>V操作用于临界区前，相当于让出同步信号</li>
<li>P、V操作<strong>不必</strong>成对匹配</li>
</ul>
</li>
<li>同步信号量的值(semaphore s: value)：<ul>
<li>>= 1 目前有s.value个s对应的同步信号</li>
<li>== 0 目前没有s对应的同步信号</li>
<li>&lt;= 0 目前有|s.value|个进程因等待s对应的同步信号而阻塞</li>
</ul>
</li>
<li>同步和互斥操作临界区重合时遵循的原则：<strong>同步在外，互斥在内</strong></li>
<li>信号量集机制<ul>
<li>一个P操作，可以同时申请多个临界资源</li>
<li>一个V操作，可以同时释放多个临界资源</li>
</ul>
</li>
</ul>
</li>
<li>管程机制<ul>
<li>管程是由局部数据结构、多个处理过程和一套初始化代码组成的模块。是一种具有<strong>面向对象</strong>程序设计思想的同步机制。提供了与信号量机制相同的功能。</li>
<li>管程结构模型<br><img src="/Pictures/管程结构模型.png" alt="管程结构模型"> </li>
<li>管程的特征<ul>
<li>管程内的数据结构只能被管程内的过程访问，任何外部访问都是不允许的</li>
<li>进程可以通过调用管程的一个过程进入管程</li>
<li>任何时间只允许一个进程进入管程，其他要求进入管程的线程统统被阻塞到等待管程的队列上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个或两个以上的进程，因为其中的每个进程都在等待其它进程做完某些事情，而整体不能继续执行，所有进程永远阻塞等待</p>
<ul>
<li>死锁产生的原因：<ul>
<li>动态资源分配策略</li>
<li>资源可用数量少于需求数量</li>
<li>进程并发过程的偶然因素</li>
<li>因为有偶然性，所以无法给出死锁产生的充分条件</li>
</ul>
</li>
<li>死锁产生的四个必要条件<ul>
<li>互斥条件：进程请求的资源属于互斥(临界)资源，每一瞬间只能由一个进程使用，其它申请该资源的进程等待</li>
<li>不可剥夺条件：进程获得某资源后，便一直占有它，直到用完为止才可以释放，其它进程不可以剥夺</li>
<li>请求和保持条件：允许一个进程在保持已有资源不放弃的情况下，进一步请求新资源，被阻塞时也不会释放已有的资源</li>
<li>环路等待条件：一组进程{P1，……， Pn}的占有资源情况与请求资源情况构成了一个环形链。有死锁一定有环</li>
</ul>
</li>
<li>死锁的描述<ul>
<li>资源请求分配图<br> <img src="/Pictures/资源请求分配图.png" alt="资源请求分配图"></li>
<li>资源请求分配矩阵<br><img src="/Pictures/资源请求分配矩阵.png" alt="资源请求分配矩阵"><br><img src="/Pictures/资源请求分配矩阵2.png" alt="资源请求分配矩阵"><br><img src="/Pictures/资源请求分配矩阵3.png" alt="例子"></li>
</ul>
</li>
<li>死锁的解决办法<ul>
<li>事前处理：针对性采取措施，让死锁没有机会发生<ul>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
</li>
<li>事后处理：即时检测、即时解除<ul>
<li>死锁检测</li>
<li>死锁解除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><ul>
<li>计算机的存储器层次结构<br><img src="/Pictures/存储器层次.png" alt="存储器层次"><br><img src="/Pictures/各级存储器性能.png" alt="各级存储器性能"></li>
<li>存储管理的管理目标<ul>
<li>内存的合理分配使用</li>
<li>提高内存利用率</li>
<li>程序、数据在内存中顺利读写</li>
<li>小内存运行大程序</li>
</ul>
</li>
<li><p>存储管理的管理功能</p>
<ul>
<li>内存的分配和回收：合理分配、即时回收</li>
<li><p>地址重定位（地址转换）：将逻辑地址转换成物理地址</p>
<ul>
<li>物理地址：存储单元的实际物理单元地址</li>
<li>逻辑地址：用户空间中使用的相对地址</li>
<li>静态重定位：地址转换工作在进程执行前一次性完成。无需硬件支持，易于实现，但不允许程序在执行过程中移动</li>
<li>动态重定位：地址转换推迟到进程执行时才完成。允许程序在主存中移动，便于主存共存，主存利用率高<br><img src="/Pictures/程序的编译链接装载和执行.png" alt="程序的编译链接装载和执行"></li>
</ul>
</li>
<li><p>地址共享和保护</p>
<ul>
<li>共享的含义<ul>
<li>共享内存储器资源，让多个进程同时进入内存区域，共享一个存储器</li>
<li>共享内存储器的某些区域，即允许两个或多个进程访问内存中同一段程序或数据</li>
</ul>
</li>
<li>地址保护的含义<ul>
<li>保护操作系统：用户进程不能访问或修改系统区</li>
<li>保护用户进程：用户进程不能访问或修改其它进程的用户区</li>
<li>保护方法<br><img src="/Pictures/保护方法.png" alt="保护方法"> </li>
</ul>
</li>
</ul>
</li>
<li>地址扩充：用存储管理软件来实现的逻辑扩充</li>
</ul>
</li>
</ul>
<h3 id="连续存储管理：一个进程装入连续的一块内存空间"><a href="#连续存储管理：一个进程装入连续的一块内存空间" class="headerlink" title="连续存储管理：一个进程装入连续的一块内存空间"></a>连续存储管理：一个进程装入连续的一块内存空间</h3><ul>
<li>单分区存储管理：内存用户区的全部空间只存放一个进程。只适用于单道系统<ul>
<li>CPU的利用率低</li>
<li>外部设备利用率低</li>
<li>内存空间浪费严重</li>
</ul>
</li>
<li><p>多分区方式：内存被分为多个分区，每个分区存放一个进程</p>
<ul>
<li><p>常用的数据结构：主存分配表MAT(Memory Allocation Table)</p>
<ul>
<li><p>主存分配表</p>
<ul>
<li>分区号：每个分区都有个编号，用以区分不同分区</li>
<li>起始地址：分区的起始地址，即首地址</li>
<li>长度：分区的总长，一般以KB为单位</li>
<li>占用标志：记录分区的使用状态，占用为0表示分区空闲，可以进行分配</li>
</ul>
</li>
<li><p>空闲分区表/链：记录内存空闲区状况的数据结构（MAT表的一个子表）,只包含空闲分区<br><img src="/Pictures/空闲分区表.png" alt="空闲分区表"></p>
<p>有空闲区链中各空闲区可按地址顺序排列，也可按尺寸大小来组织，当系统进行内存分配时，进行的处理是：</p>
<ul>
<li>通过空闲区链快速搜索内存的空闲区</li>
<li>从中找出最合适的分区分配出去</li>
<li>将该节点从链上删除 </li>
</ul>
<p>当需要回收某块被释放的区域时，系统处理过程为：</p>
<ul>
<li>按其地址或者大小在链中找到合适的位置</li>
<li>插入一个新节点，记录回收分区的起始地址和长度</li>
<li>若存在相邻的空闲区，需要的话可将相邻空闲区合并  </li>
</ul>
</li>
</ul>
</li>
<li><p>固定多分区：分区数目是固定的，每个分区的起始地址和长度固定。MAT表可用静态数组实现 </p>
<ul>
<li>内碎片：小进程装入大分区后的闲置内存空间。降低了内存的有效利用率，但不可避免</li>
<li>采用静态地址重定位</li>
<li>适用的主存分配算法：最佳适应算法(<strong>Best Fit</strong>)</li>
</ul>
</li>
<li>动态多分区：系统不预先划分固定分区，而是在装入进程时，根据进程的实际需求量划分出一个小分区给它适用。MAT分区表需要用动态数组来实现<ul>
<li>外碎片：零星的、因为太小不太容易被分配利用的小空闲区</li>
<li>主存分配算法只会讲分区越分越小，几乎都不适应</li>
<li>消除外碎片的方法： <ul>
<li>主存分配过程中，通过程序浮动将不相邻的空闲分区移为相邻的进行合并</li>
<li>回收过程中相邻空闲区进行合并</li>
</ul>
</li>
<li>动态多分区存储保护<br><img src="/Pictures/动态多分区存储保护.png" alt="动态多分区存储保护"> <ul>
<li>基址寄存器记录当前进程所占分区的首地址</li>
<li>限长寄存器记录当前进程的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>多分区主存分配算法：</p>
<ul>
<li><p>首次适应算法First_Fit</p>
<p>系统将内存分区按地址递增顺序登记到内存分配表（或空闲分区表）中，每次进行分配时，系统根据进程申请空间的大小，从头到尾扫描内存分配表（或空闲分区表），从中找到第一块满速要求的空闲区分配出去</p>
</li>
<li><p>循环首次适应算法Circle_First_fit</p>
<p>将内存中所有的空闲分区从低址到高址组成一个循环链表，每次分配时从上次分配的位置开始向尾部查找，查找到第一个可满足的空闲空间分配给用户。当查到表尾仍未找到则转到头部继续</p>
</li>
<li><p>最佳适应算法Best_Fit</p>
<p>从空闲区表中找打一块满足需求的最小空闲分区分配给用户</p>
</li>
<li><p>最坏适应算法Worse_Fit</p>
<p>从空闲区表中找打一块满足需求的最大空闲分区分配给用户</p>
</li>
</ul>
</li>
</ul>
<h3 id="非连续存储管理"><a href="#非连续存储管理" class="headerlink" title="非连续存储管理"></a>非连续存储管理</h3><ol>
<li><p>分页方式：内存被划分为多个等长的存储块，每个进程占用其中的若干块，整个内存允许有多个进程同时驻留</p>
</li>
<li><p>多段方式：对分段结构的应用程序，按照长度分贝位置分配内存空间</p>
</li>
<li><p>段页方式：在分段式管理的基础上加上分页式管理可形成段页式管理</p>
</li>
</ol>
<ul>
<li><p>基本分页存储管理</p>
<ul>
<li>内存被划分成大小固定相等的块(Frame帧、页框、主存块)，且块相对较小</li>
<li>每个进程装入时被分为同样大小的页(Page)，一页装入一帧。<ul>
<li>页面尺寸（长度）由计算机系统的硬件决定，一台机器只能规定一种尺寸。</li>
<li>目前流行的页面尺寸在1KB到4KB之间</li>
</ul>
</li>
<li><p>整个进程被离散装入到多个不连续的帧</p>
</li>
<li><p>记录内存使用情况的数据结构：位示图</p>
<p>整个系统一张图，记录内存的使用情况</p>
<p><img src="/Pictures/记录内存的数据结构.png" alt="记录内存的数据结构"> </p>
<ul>
<li>每一行代表一个字</li>
<li>每一列代表一个位</li>
<li>每个元素代表一个帧：0为空闲，1为占用</li>
<li>分配时，找到值为0的位，将值改为1，根据字号和位号换算出帧号，并记录</li>
<li>释放时，根据记录的帧号换算出字号和位号，将值从1改为0</li>
</ul>
</li>
<li><p>记录每个进程分页及占用内存情况的数据结构：分页表(PT)</p>
<p>登记进程各页面对应的帧号，供地址映射使用。记录该进程分了多少个页，每一页占用哪一个帧</p>
<p><img src="/Pictures/页表示例.png" alt="页表示例"></p>
<ul>
<li>页面分配算法</li>
</ul>
<ol>
<li>计算请求者需要的总帧数N</li>
<li>查位图，若找不到足够的空闲帧，返回分配失败</li>
<li>索取一个空闲页表PT</li>
<li>从位图中找出N个0位，计算出对应的帧号，填入PT</li>
<li>在位示图将这些为改为1</li>
<li>将PT其实地址填入进程的PCB中</li>
</ol>
</li>
<li><p>地址划分</p>
<ul>
<li>进程装入之前，逻辑地址是一维的</li>
<li>进程装入（分页）之后，逻辑地址分为二维：页号和页内偏移量（页内地址）</li>
<li>地址划分例子<br><img src="/Pictures/地址划分.png" alt="地址划分"></li>
<li>地址重定位<br><img src="/Pictures/地址重定位.png" alt="地址重定位">  </li>
<li>地址保护<br><img src="/Pictures/地址保护.png" alt="地址保护"> </li>
</ul>
</li>
<li>总结：<ul>
<li>离散存储，利于大进程装入</li>
<li>只有很少的页内碎片，每个进程只有最后一页可能占不满整个帧，提高内存利用率</li>
</ul>
</li>
</ul>
</li>
<li><p>基本分段存储管理</p>
<ul>
<li>“段”是一个逻辑单位，是进程的一个组成部分。如主程序段、子程序段、数据段等</li>
<li>原理<ol>
<li>进程的程序和其相关的数据按逻辑分段</li>
<li>段有一个最大长度限制，但不要求所有程序的所有段的长度都相等</li>
<li>一段一段占用一块连续存储区</li>
<li>各段占用不连续分区，实现离散存储</li>
</ol>
</li>
<li>记录内存使用情况的数据结构：<ul>
<li>MAT</li>
<li>空闲分区表/链</li>
<li>这里的MAT与动态多分区中MAT表的异同：<ul>
<li>相同点：MAT的一个表项对应内存一个分区</li>
<li>不同点：分区中存放的内容不同<ul>
<li>动态多分区中，一个分区存放一整个进程</li>
<li>分段存储中，一个分区存放进程的一个段。一个进程离散成多个段装入多个不连续的分区</li>
</ul>
</li>
</ul>
</li>
<li>记录各个进程分段情况的数据结构<ul>
<li>段表ST(Segment Table)，为每个进程设置一张段表，用来记录各个段地址映射的关系<ul>
<li>进程分了几段，段表就有几个表项</li>
<li>一个表项记录一个分段在内存空间中的存储地址和长度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>地址重定位<br><img src="/Pictures/地址重定位1.png" alt="地址重定位"> </li>
<li>分段保护<ul>
<li>第一级保护是防止进程发生超出存储空间的访问</li>
<li>第二级保护是组织进程超出访问权限的读写</li>
<li><img src="/Pictures/分段保护.png" alt="分段保护"><ul>
<li>S表示段号</li>
<li>d表示段内偏移</li>
</ul>
</li>
</ul>
</li>
<li>段面共享：<ul>
<li>将内存中共享段的起始地址以及长度填入需要共享的用户进程的段表中 </li>
<li>共享段表SST(Sharing Segment Table)：记载各个共享段的使用情况，任何一个进程调用共享段时，系统都将访问该表<br><img src="/Pictures/共享段表实例.png" alt="共享段表实例"></li>
</ul>
</li>
</ul>
</li>
<li><p>基本段页式存储管理</p>
<ul>
<li>分页与分段：<ul>
<li>分页：<ul>
<li>有利于大进程装入，内存利用率高</li>
<li>页是物理页，页面共享不易实现</li>
</ul>
</li>
<li>分段：<ul>
<li>段是逻辑段，方便实现分段共享</li>
<li>外碎片的存在降低内存的使用效率，且整理消除外碎片会加大系统开销</li>
</ul>
</li>
</ul>
</li>
<li>段页式：<ul>
<li>内存划分成大小相等的页框（帧）</li>
<li>用户的地址空间划分为多个段，每个段按照帧的大小一次划分成多个固定大小的页，页的长度等于内存中的页框大小</li>
</ul>
</li>
<li>记录内存使用情况的数据结构<ul>
<li>位示图，记录内存各帧是否占用</li>
<li>段表，记录各个分段对应段页表的地址和长度</li>
<li>段内页表，记录该段划分为多少页，每页分配的帧号是多少<br><img src="/Pictures/段表和段内页表.png" alt="段表和段内页表"> </li>
</ul>
</li>
<li>地址形式：<ul>
<li>处理器内部的硬件支持：段表控制寄存器、地址生成逻辑</li>
</ul>
<ol>
<li>程序中的逻辑地址仍然是二维地址：&lt;段号， 偏移量&gt;</li>
<li>每段装入时分页，地址部分被当作三维地址类处理：&lt;段号，页号，页内偏移&gt; </li>
</ol>
</li>
<li>段页式地址重定位<br><img src="/Pictures/段页式地址重定位.png" alt="段页式地址重定位">  </li>
<li>段页式地址保护<br><img src="/Pictures/段页式地址保护.png" alt="段页式地址保护"> </li>
<li>段页式地址字结构的计算<br><img src="/Pictures/段页式地址字结构的计算.png" alt="段页式地址字结构的计算"></li>
</ul>
</li>
</ul>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/12/31/Welcome/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          Welcome
        
      </div>
    </a>
  
  
    <a href="/2020/03/16/UnicodeProgramming/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Unicode note</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>


<div class="ds-share share" data-thread-key="操作系统" data-title="操作系统" data-url="http://yoursite.com/2020/03/16/操作系统/" data-images="https://weizheblog.gitee.io/Pictures/timg.ico" data-content="操作系统">
    <div class="ds-share-inline">
      <ul class="ds-share-icons-16">
      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
 </div>
 





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2020 Weizhe Yang
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>
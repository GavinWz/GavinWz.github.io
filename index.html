<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Gavin-Gavin</title>

  <!-- keywords -->
  
    <meta name="keywords" content="Gavin">
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Study Record Blog">
<meta name="keywords" content="Gavin">
<meta property="og:type" content="website">
<meta property="og:title" content="Gavin">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Gavin">
<meta property="og:description" content="Study Record Blog">
<meta property="og:locale" content="English & Chinese">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Gavin">
<meta name="twitter:description" content="Study Record Blog">
  
    <link rel="alternative" href="/atom.xml" title="Gavin" type="application/atom+xml">
  
  
    <link rel="icon" href="https://gitee.com/weizheblog/weizheblog/blob/master/Pictures/timg.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
      <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("your_app_id", "your_app_key");</script>
<script src="/js/Counter.js"></script>
  
</head></html>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://gitee.com/weizheblog/weizheblog/blob/master/Pictures/timg.ico" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Weizhe Yang</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Gavin</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/GavinWz/" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/HPC/" style="font-size: 10px;">HPC</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://www.iczc.me/">iczc</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">A student of the College of Computer Engineering of Weifang University. I&#39;m learning hard on Information Technology, and this is where I save my study records.Not all the essays here are my original works, but some of them have helped me a lot in the past time, so I recorded them to share with everyone and it also remind me what should I do if I face the same situations which I have met in the past but forgot how to operate now.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Weizhe Yang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://gitee.com/weizheblog/weizheblog/blob/master/Pictures/timg.ico" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Weizhe Yang</h1>
			</hgroup>
			
			<p class="header-subtitle">Gavin</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/GavinWz/" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Welcome" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/12/31/Welcome/" class="article-date">
  	<time datetime="2020-12-31T02:06:18.000Z" itemprop="datePublished">2020-12-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/31/Welcome/">
        Welcome
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Welcome"><a href="#Welcome" class="headerlink" title="Welcome!"></a>Welcome!</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__        __         _                                       _             _                           _</span><br><span class="line">\ \      / /  ___  | |   ___    ___    _ __ ___     ___   _| |_    ___    | |__     ___   _ __   ___  | |</span><br><span class="line"> \ \ /\ / /  / _ \ | |  / __|  / _ \  | &apos;_ ` _ \   / _ \  |_ __|  / _ \   | &apos;_ \   / _ \ | &apos;__| / _ \ | |</span><br><span class="line">  \ V  V /  |  __/ | | | (__  | (_) | | | | | | | |  __/   | |_  | (_) |  | | | | |  __/ | |   |  __/ |_|</span><br><span class="line">   \_/\_/    \___| |_|  \___|  \___/  |_| |_| |_|  \___|    \__|  \___/   |_| |_|  \___| |_|    \___| (_)</span><br></pre></td></tr></table></figure>
<h3 id="Welcome-to-Weizhe’s-blog-I’m-learning-hard-on-Information-Technology-and-this-is-where-I-save-my-study-records-Not-all-the-essays-here-are-my-original-works-but-some-of-them-have-helped-me-a-lot-in-the-past-time-so-I-recorded-them-to-share-with-everyone-and-it-also-remind-me-what-should-I-do-if-I-face-the-same-situations-which-I-have-met-in-the-past-but-forgot-how-to-operate-now"><a href="#Welcome-to-Weizhe’s-blog-I’m-learning-hard-on-Information-Technology-and-this-is-where-I-save-my-study-records-Not-all-the-essays-here-are-my-original-works-but-some-of-them-have-helped-me-a-lot-in-the-past-time-so-I-recorded-them-to-share-with-everyone-and-it-also-remind-me-what-should-I-do-if-I-face-the-same-situations-which-I-have-met-in-the-past-but-forgot-how-to-operate-now" class="headerlink" title="Welcome to Weizhe’s blog, I’m learning hard on Information Technology, and this is where I save my study records.Not all the essays here are my original works, but some of them have helped me a lot in the past time, so I recorded them to share with everyone and it also remind me what should I do if I face the same situations which I have met in the past but forgot how to operate now."></a>Welcome to Weizhe’s blog, I’m learning hard on Information Technology, and this is where I save my study records.Not all the essays here are my original works, but some of them have helped me a lot in the past time, so I recorded them to share with everyone and it also remind me what should I do if I face the same situations which I have met in the past but forgot how to operate now.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    .- &lt;O&gt; -.        .-====-.      ,-------.      .-=&lt;&gt;=-.</span><br><span class="line">   /_-\&apos;&apos;&apos;/-_\      / / &apos;&apos; \ \     |,-----.|     /__----__\</span><br><span class="line">  |/  o) (o  \|    | | &apos;)(&apos; | |   /,&apos;-----&apos;.\   |/ (&apos;)(&apos;) \|</span><br><span class="line">   \   ._.   /      \ \    / /   &#123;_/(&apos;) (&apos;)\_&#125;   \   __   /</span><br><span class="line">   ,&gt;-_,,,_-&lt;.       &gt;&apos;=jf=&apos;&lt;     `.   _   .&apos;    ,&apos;--__--&apos;.</span><br><span class="line"> /      .      \    /        \     /&apos;-___-&apos;\    /    :|    \</span><br><span class="line">(_)     .     (_)  /          \   /         \  (_)   :|   (_)</span><br><span class="line"> \_-----&apos;____--/  (_)        (_) (_)_______(_)   |___:|____|</span><br><span class="line">  \___________/     |________|     \_______/     |_________|</span><br></pre></td></tr></table></figure>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        
<div class="counter-tag counter">
    <span id="/2020/12/31/Welcome/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="Welcome">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-操作系统" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/16/操作系统/" class="article-date">
  	<time datetime="2020-03-16T07:42:33.000Z" itemprop="datePublished">2020-03-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/16/操作系统/">
        操作系统
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h3><ul>
<li><p>操作系统以下是硬件，以上是编译系统等一些支撑软件或者系统使用软件，再往上是实现各个具体应用任务的应用软件。操作系统是最贴近硬件层的系统软件。</p>
</li>
<li><p>操作系统是人机交互的桥梁，为用户提供人机界面，提供便捷、高效的运行环境和服务。</p>
</li>
<li><p>操作系统管理所有硬件资源；控制调度所有程序的运行过程；通过软件的管理方法虚拟地扩充硬件功能</p>
</li>
<li><p>操作系统的概念：一种管理系统资源、控制程序执行、改善人机界面、提供各种服务，并合理组织计算机工作流程和为用户方便有效地使用计算机提供良好的运行环境的一种<strong>系统软件</strong></p>
</li>
<li><p>操作系统发展的两大动力：</p>
<ul>
<li>资源的管理需求</li>
<li>用户的使用需求</li>
</ul>
</li>
<li><p>计算机上出现的第一个操作系统：Monitor（单任务操作系统的雏形）</p>
</li>
<li><p>CTSS（Compatible Time-Sharing System）兼容分时系统：将主机连接多个终端，把CPU的处理时间划分了多个时间片，每个时间片处理一个终端上的交互操作。实现多人共享一台计算机资源</p>
</li>
<li><p>UNIX是一个通用的、多用户、多任务的分时操作系统</p>
</li>
<li><p>操作系统在计算机系统中的地位：<br><img src="/Pictures/操作系统在计算机系统中的地位.png" alt="操作系统在计算机系统中的地位"></p>
</li>
<li><p>操作系统的作用<br><img src="/Pictures/操作系统的作用.png" alt="操作系统的作用"></p>
<ul>
<li>为用户提供了实现各种功能的接口</li>
<li>管理系统中所有的资源，硬件和软件，使之能为用户提供更好地服务</li>
<li>在管理和发挥计算机自身的硬件性能的基础上虚拟扩充硬件的功能</li>
<li>控制所有的程序在系统中协调一致地运行</li>
</ul>
</li>
<li><p>操作系统的主要目标</p>
<ul>
<li>方便用户使用</li>
<li>管理系统资源</li>
<li>提高系统效率</li>
<li>扩大机器功能</li>
<li>构筑开放环境</li>
</ul>
</li>
<li><p>操作系统资源管理技术<br><img src="/Pictures/资源管理技术.png" alt="资源管理技术"></p>
<ul>
<li>资源复用：<ul>
<li>空分复用共享：该资源可以进一步分割成更多和更小的单位供进程使用，如内存空间。</li>
<li>时分复用共享：并不把资源进一步分割成更小的单位，进程可以再一个时间段内独占整个屋里资源。如CPU。</li>
</ul>
</li>
<li>资源虚拟<br><img src="/Pictures/资源虚拟.png" alt="资源虚拟"></li>
</ul>
</li>
<li><p>计算机在操作系统的管理下，使得每个用户进程就好像在一台虚拟机上运行一样<br><img src="/Pictures/操作系统虚拟机.png" alt="操作系统虚拟机"></p>
</li>
<li><p>操作系统的资源管理技术<br>对于一类资源，操作系统往往同时实施几种资源管理技术   </p>
<ul>
<li><p>例1：虚拟设备–抽象+虚拟</p>
</li>
<li><p>例2：虚拟主存–复用+虚拟<br>既把内存空间划分为多块实现复用，又通过虚拟扩充技术使得磁盘空间可以虚拟为内存使用</p>
</li>
</ul>
</li>
</ul>
<h3 id="操作系统的处理方式"><a href="#操作系统的处理方式" class="headerlink" title="操作系统的处理方式"></a>操作系统的处理方式</h3><ul>
<li>批处理方式：成批提交成批处理<ul>
<li>接收一批作业到外存，组织成作业流</li>
<li>自动控制一批作业的内存装入和运行过程</li>
<li>全部完成后再将结果反馈给用户</li>
<li>单道批处理方式：一个时间段内，只有一个用户程序在运行<ul>
<li>成批提交</li>
<li>单道装入</li>
<li>顺序运行</li>
</ul>
</li>
<li>多道程序设计技术：是指允许多个程序同时进入一个计算机系统的主存储器并启动进行计算的方法<ul>
<li>成批提交</li>
<li>多道装入</li>
<li>优点：系统系统资源利用率高、系统吞吐量大</li>
<li>缺点：成批处理过程中无交互性（系统自动控制）、用户作业的等待时间长</li>
</ul>
</li>
</ul>
</li>
<li>分时处理方式<ul>
<li>在多道程序设计基础上发展起来的一种处理方式，强调交互性</li>
<li>分时技术：将CPU时间划分为时间片，每个时间片轮流执行用户程序</li>
<li>特征：同时性、交互性、独占性、及时性</li>
</ul>
</li>
<li><p>实时处理方式</p>
<ul>
<li>突出系统处理的即时性或响应性</li>
<li>硬式实时系统，对时间严格约束<ul>
<li>采用专用的管理调度方式</li>
</ul>
</li>
<li>软式实时系统，对时间有限制和要求，但是没有严格的截止时间（deadline）</li>
</ul>
</li>
<li><p>操作系统的功能组成</p>
<ul>
<li>管理对象：<ul>
<li>用户</li>
<li>软硬件资源</li>
</ul>
</li>
<li>管理目标：充分发挥资源小路，甚至虚拟扩充资源的性能，为用户提供最快最好的服务</li>
<li>操作系统的主要管理功能<ul>
<li>用户和接口管理：负责用户身份核实，操作权限管理以及各种人机接口的实现<ul>
<li>用户管理</li>
<li>用户组管理</li>
<li>联机接口管理</li>
<li>脱机接口管理</li>
<li>程序级接口管理</li>
</ul>
</li>
<li>处理机管理（进程管理）：围绕CPU的调度，负责管理、控制用户程序的动态执行过程<ul>
<li>进程控制和管理</li>
<li>进程同步和互斥</li>
<li>进程通信</li>
<li>进程死锁</li>
<li>线程控制和管理</li>
<li>四级调度</li>
</ul>
</li>
<li>存储管理：负责为正在运行的程序分配内存空间，并实现地址和空间有关的管理功能<ul>
<li>内存分配</li>
<li>地址转换</li>
<li>存储保护</li>
<li>内存共享</li>
<li>存储扩充</li>
</ul>
</li>
<li>设备管理：负责外存和I/O设备的分配、驱动和调度控制，以及实现外设读写的相关机制。<ul>
<li>设备的分配和回收</li>
<li>设备的驱动调度</li>
<li>实现罗技设备到物理设备之间的映射</li>
<li>提供设备中断处理</li>
<li>提供缓冲区管理</li>
<li>实现虚拟设备</li>
</ul>
</li>
<li>文件管理：负责建立、存取、目录管理、共享保护以及文件存储空间的管理<ul>
<li>提供文件的逻辑组织方法</li>
<li>提供文件的物理组织方法</li>
<li>提供文件的存取和使用方法</li>
<li>实现文件的目录管理</li>
<li>实现文件的共享和安全性控制</li>
<li>实现文件的存储空间管理</li>
</ul>
</li>
<li>网络与通信管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="操作系统的内核（kernel）"><a href="#操作系统的内核（kernel）" class="headerlink" title="操作系统的内核（kernel）"></a>操作系统的内核（kernel）</h3><p>内核是作为可信软件来提供支持进程并发执行的基本功能和基本操作的一组程序（内核程序）。如时钟管理、CPU调度、内存分配等。在开机时，内核程序一定会装入内存中的内核空间中，运行于CPU的核心态下，具有访问硬件设备和所有主存空间的权限。</p>
<ul>
<li>内核的属性<ul>
<li>中断驱动</li>
<li>不可抢占</li>
<li>可以再屏蔽中断状态下执行</li>
<li>可以使用特权指令</li>
</ul>
</li>
<li>内核分类：<ul>
<li>单内核：Linux<br><img src="/Pictures/LInux单体式单内核结构.png" alt="单内核"></li>
<li>微内核<br><img src="/Pictures/微内核操作系统.png" alt="微内核"></li>
</ul>
</li>
<li>PC机DOS操作系统启动过程<br><img src="/Pictures/PC机开机过程.png" alt="启动过程">    <img src="/Pictures/PC机开机过程2.png" alt="启动过程">  </li>
</ul>
<h3 id="操作系统的主要特征"><a href="#操作系统的主要特征" class="headerlink" title="操作系统的主要特征"></a>操作系统的主要特征</h3><ul>
<li><p>并发性：在一个时间段内，多个程序处于宏观的运行状态，并发推进。让有限的物理资源实现多用户共享，一提高效率<br><img src="/Pictures/串并发.png" alt="串并并发"> </p>
<p>优点：</p>
<ul>
<li>一个时间段内，多个程序（进程）共享系统资源</li>
<li>发挥并发性能够消除系统中部件和部件之间的相互等待，有效的改善系统资源的利用率</li>
</ul>
<p>进程并发必须解决的问题：<br><img src="/Pictures/进程并发必须解决的问题.png" alt="进程并发必须解决的问题"></p>
<p>并发的实质是一个物理COU（也可以多个）在若干道程序之间的多路复用</p>
</li>
<li>共享性：操作系统中的资源可以被多个并发执行的进程所使用<ul>
<li>同时共享：同时具有使用权。涉及透明资源共享（资源隔离与授权访问）</li>
<li>互斥共享：轮流使用。涉及显式资源共享（临界资源与独占访问）</li>
</ul>
</li>
<li><p>异步性<br><img src="/Pictures/异步性.png" alt="异步性"> </p>
<p>异步性给系统带来潜在的危险，有可能导致<strong>与时间有关的错误</strong><br>面对异步性系统，操作系统的一个重要的任务是必须确保捕捉任何一种随机事件，正确处理，否则将会导致严重后果。</p>
</li>
<li>虚拟性：利用某种技术奖少的物理资源演变为多的、逻辑上的对应资源；还包括将慢的虚拟成快的、容量小的虚拟成容量大的、不能共享的虚拟成能共享的，等。</li>
</ul>
<h2 id="作业管理模块"><a href="#作业管理模块" class="headerlink" title="作业管理模块"></a>作业管理模块</h2><ul>
<li><p>概念：</p>
<ul>
<li>作业管理模块是操作系统中最外层的直接面对用户的模块</li>
<li>为用户提供系统接口，将用户需求提交系统，再将处理结果反馈用户</li>
<li>负责用户管理，核准用户合法性，管理用户使用资源及费用等情况</li>
</ul>
</li>
<li><p>作业：用户提交给计算机系统的任务</p>
<ul>
<li>程序： 完成任务所要执行的代码</li>
<li>数据： 代码执行过程处理的数据</li>
</ul>
</li>
<li><p>作业的不同类别</p>
<ul>
<li>批处理型作业：批处理方式提交的作业<br><img src="/Pictures/批处理作业.png" alt="批处理型作业"></li>
<li>交互型作业：以交互方式提交的作业<br><img src="/Pictures/交互型作业.png" alt="交互型作业"></li>
<li>实时型作业：特指相应时间有实时需求的作业<br><img src="/Pictures/实时型作业.png" alt="实时型作业"><ul>
<li>硬实时作业：有严格的响应时间的控制，不在某个时间点相应的话，效益为零</li>
<li>软实时作业：按要求的相应时间相应效益最佳，但不会直接降为零<br><img src="/Pictures/硬实时软实时.png" alt="硬实时软实时"> </li>
</ul>
</li>
<li>不同作业类别的管理、调度方式不同<br><img src="/Pictures/作业类别.png" alt="作业类别"></li>
</ul>
</li>
<li><p>作业管理模块的功能</p>
<ul>
<li><p>用户管理</p>
<ul>
<li>新建用户</li>
<li>删除用户</li>
<li>验证身份</li>
<li>维护用户信息</li>
<li>配置用户运行环境</li>
<li>设置用户权限</li>
<li>用户组的设置与管理</li>
<li>用途：方便计费，方便系统安全管理</li>
</ul>
</li>
<li><p>接口管理</p>
<ul>
<li>操作员接口 || 程序员接口</li>
<li>联机接口 || 脱机接口</li>
</ul>
</li>
<li><p>批作业的管理控制与调度</p>
<ul>
<li>作业状态</li>
<li>作业控制块</li>
<li>作业调度</li>
<li>作业的装载与卸出</li>
<li>将批作业收容到外存的“作业输入井”中，建立“作业控制块”记录作业控制信息，通过作业调度选择后背作业装载内存，并在作业完成后将作业卸出</li>
</ul>
</li>
</ul>
</li>
<li><p>作业的管理控制</p>
<ul>
<li><p>批作业的状态管理：批作业的每个运行阶段用一个状态来描述，不同的运行阶段通过状态之间的转换来进行控制</p>
</li>
<li><p>批作业控制块（JCB）：记录作业的各项属性和管理信息。内容包括：</p>
<ul>
<li>作业号</li>
<li>作业类别</li>
<li>用户名及用户账号</li>
<li>作业状态</li>
<li>提交到系统的时间</li>
<li>优先级（响应比）</li>
<li>作业所在的外存位置</li>
<li>资源需求</li>
<li>运行长度</li>
<li>运行的时间</li>
<li>其它信息（收费标准，JCB队列指针等）</li>
</ul>
</li>
<li><p>不同作业I/O方式</p>
<ul>
<li>联机I/O：主机连接I/O设备，在作业运行过程中，占用着CPU进行输入和输出过程。缺点：快速的CPU等待满速的I/O设备</li>
<li>脱机I/O：将I/O操作与主机运行相脱离，单独设置专用的输入输出计算机</li>
<li>假脱机方式（现代操作系统）：又称为“在线外设并行访问”，简记为Spooling。在这种方式中，不再单独设置专用的输入输出计算机，而是将输入输出功能从操作系统内核中分离出来，单独形成I/O进程，来完成用户的输入输出工作<br><img src="/Pictures/假脱机.png" alt="假脱机"> </li>
</ul>
</li>
<li><p>不同作业控制方式 </p>
</li>
</ul>
<p>操作系统必须对用户作业的全过程实施控制，包括，怎样将作业输入到计算机中去、怎样控制作业的运行、运行出现故障后如何进行处理、作业运行结束后输出哪些内容</p>
<ul>
<li>脱机作业控制：一般适用于批处理系统中，所有作业的控制信息都由用户按照系统提供的作业控制语言来编制。用户提交作业之后，作业的运行完全脱离用户的干预。</li>
<li>联机作业控制：大多数分时系统和实时系统采用的一种作业控制方式，整个控制过程由用户使用操作系统提供的操作命令，与计算机通过交互会话方式来控制作业执行</li>
<li>批作业与交互作业控制方式的不同<br><img src="/Pictures/批作业与交互作业控制方式的不同.png" alt="批作业与交互作业控制方式的不同"> </li>
</ul>
</li>
</ul>
<ul>
<li>批作业的状态<ul>
<li>“后备状态”：已经提交到外存的“作业收容井”，等待调度装入</li>
<li>“驻留状态”（运行状态）：被作业调度选中，已经装入内存，处于宏观的运行状态</li>
<li>“完成状态”：作业相关代码已经执行结束，已不再占用内存空间和系统各种设备，正在等待卸出和数据缓输出<br><img src="/Pictures/作业转换图.png" alt="作业转换图">  </li>
</ul>
</li>
</ul>
<h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2><p>  <img src="/Pictures/操作系统接口.png" alt="操作系统接口"> </p>
<ul>
<li>脱机命令接口———作业的控制说明语言<ul>
<li>批处理系统中，用户提交给系统的一个计算任务就是一个作业</li>
<li>批作业 = 程序 + 数据 + 作业控制说明书</li>
<li>作业控制说明书由作业控制语言编写，也就是由一条条控制作业如何运行的命令组成。是计算机系统给批用户提供的一个接口</li>
<li>作业控制说明语言是由一组作业控制命令组成的集合，专门用于批处理系统</li>
</ul>
</li>
<li><p>联机命令接口（人机交互方式）</p>
<ul>
<li>命令行方式操作接口（键盘命令）</li>
<li>图形化界面（鼠标点击）</li>
<li>涉及的服务程序：<ul>
<li>终端处理程序</li>
<li>命令解释程序</li>
<li>鼠标点击事件响应程序</li>
</ul>
</li>
</ul>
</li>
<li><p>程序级接口———系统调用</p>
<ul>
<li>一种适用于应用程序中的功能调用接口，允许用户在自己的应用程序中调用系统提供的一些功能模块。即应用程序调用系统程序</li>
<li>系统调用时应用程序获得操作系统服务的唯一途径<br><img src="/Pictures/系统调用.png" alt="系统调用"><br><img src="/Pictures/系统调用的服务例程.png" alt="系统调用的服务例程"></li>
<li>CPU的两种工作状态<ul>
<li>管态（系统态）：执行系统程序的状态，允许执行所有指令</li>
<li>目态（用户态）：执行用户程序的状态，只允许执行非特权指令<br><img src="/Pictures/系统调用的前后.png" alt="系统调用的前后"></li>
</ul>
</li>
<li>系统调用分类<ul>
<li>进程和作业管理类</li>
<li>文件操作类</li>
<li>设备管理类</li>
<li>主存管理类</li>
<li>信息维护类</li>
<li>通信类</li>
</ul>
</li>
<li>系统调用与API函数的区别<ul>
<li>系统调用：程序级接口，通过该接口用户可以调用操作系统提供的功能模块（以函数形式提供）。系统调用的服务例程在<strong>管态</strong>下执行，</li>
<li>API：系统提供的应用函数库，也称应用程序接口，将一些常用的功能函数事先实现，供用户程序直接调用，其中一些API函数的实现过程调用了一个或几个系统调用。API函数在<strong>目态</strong>下执行。</li>
</ul>
</li>
<li>Linux系统程序、程序调用、库函数、应用程序分层关系<br><img src="/Pictures/分层关系.png" alt="分层关系"></li>
<li>系统调用的实现过程<ul>
<li>为系统调用编写处理内核函数   </li>
<li>设计一张系统调用入口地址表，每个入口地址都指向一个系统调用的内核函数，有的系统还包含系统调用自带参数的个数。</li>
<li>陷入处理机制：中断要进行系统调用的用户进程，开辟现场保护区，将被中断进程的现场信息存储到保护区内，以保存发生系统调用时的处理器现场。</li>
</ul>
</li>
<li>系统调用的处理过程<br><img src="/Pictures/系统调用的处理过程.png" alt="系统调用的处理过程"></li>
</ul>
</li>
</ul>
<h2 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h2><ul>
<li>作业调度又称“高级调度”：<ul>
<li>是批处理系统中采用的一级调度。</li>
<li>主要功能是，从处于后备状态的作业中按照某种算法选择一道或者几道作业装入内存，被选中的作业就从收容或者后备状态转入到驻留状态。</li>
<li>作业调度解决的是作业与作业之间的自动转接问题，即免去作业控制中的人工操作问题</li>
</ul>
</li>
<li>作业调度算法：<br><img src="/Pictures/作业调度算法.png" alt="作业调度算法"><ul>
<li>FCFS(First Come First Served)<ul>
<li>选择最先进入后备队列的作业装入内存</li>
<li>优点：容易实现</li>
<li>缺点：<br>不分作业长短，对短小作业十分不利；<br>不顾轻重缓急；<br>对时间要求紧迫的作业不能做到急事急办</li>
</ul>
</li>
<li>SJF(Shortest Job First)<ul>
<li>从后备作业中选择运行时间最短的作业装入内存</li>
<li>优点：照顾短作业用户的利益，提高系统吞吐量，让作业的<strong>平均周转时间</strong>降下来</li>
<li>缺点：推迟长作业的运行，可能出现饥饿现象。  <pre><code>估计运行时间本身有可能不太准确
</code></pre></li>
</ul>
</li>
<li>HRF<ul>
<li><img src="/Pictures/HRF.png" alt="HRF"> </li>
<li>优点：折中考虑到作业进入系统的先后次序，又顾及到作业的运行时间</li>
<li>缺点：每次调度都要计算每个作业的相应比，开销大</li>
</ul>
</li>
<li>HPF(Highest Response First)优先级调度算法<ul>
<li>每次总是选择后备作业中优先级最高的作业装入内存</li>
<li>当一个作业进入系统，系统根据多方面因素（用户级别、用户租金、作业类别等）会为作业赋予一个优先级</li>
<li>比较灵活，优先级可以根据需要灵活确定</li>
<li>经常作为基于<strong>作业运行紧迫性</strong>的一种调度方案</li>
</ul>
</li>
<li>均衡调度算法<br><img src="/Pictures/均衡调度算法.png" alt="均衡调度算法"><ul>
<li>根据内存容量的限制，选择一组资源互补型的作业装入</li>
<li>目的：在作业运行期间，尽可能提高CPU和各种设备之间的并行度，从而提高整个系统的效率</li>
</ul>
</li>
</ul>
</li>
<li>作业调度性能的衡量准则<ul>
<li>系统吞吐量<br><img src="/Pictures/系统吞吐量.png" alt="系统吞吐量"><br>平均周转时间：<br><img src="/Pictures/平均周转时间.png" alt="平均周转时间"></li>
<li>对短作业优惠<ul>
<li>主要为了吸引中小用户使用计算机</li>
<li>为了描述系统对短小作业的优惠程度，可以用作业的平均带权周转时间W作为评价参数   </li>
<li>定义：平均带权周转时间<br><img src="/Picture/平均带权周转时间.png" alt="平均带权周转时间"></li>
</ul>
</li>
<li>其他指标<br><img src="/Pictures/其他指标.png" alt="其他指标"> </li>
</ul>
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程的表述：进程是一个程序的一次动态执行过程</p>
<ul>
<li>一个正在计算机上执行的程序</li>
<li>一个能分配给处理器执行的实体</li>
<li>一个具有一下特征的活动单元：一组指令序列的执行、一个当前状态和相关的系统资源集</li>
</ul>
<p>进程的重要性：</p>
<ul>
<li>是操作系统最核心的概念之一</li>
<li>是操作系统要面对的最核心的管理对象</li>
<li>是占用CPU资源和其它资源的实体</li>
<li>用户的所有程序均通过进程(用户进程)的形式运行</li>
<li>操作系统给用户提供的各种服务也是以进程(系统进程)的形式运行</li>
<li>进程管理模块是操作系统最核心的一个模块</li>
<li>学习操作系统内核从学习操作系统如何建立、管理、调度进程开始</li>
</ul>
<p>引进进程对操作系统的作用:</p>
<ul>
<li>使用进程描述每一个程序的每一次动态执行</li>
<li>通过进程实体来管理控制每一个程序的每一次执行过程</li>
<li>操作系统引进“子进程”，使大程序的程序段可以并发，以加快程序推进并且提高CPU利用率</li>
</ul>
<p>现代操作系统是多道程序设计系统：多道程序并发运行，共享(竞争) CPU、内存I/O设备等资源。</p>
<p>并发运行方式的基本特征：</p>
<ul>
<li>异步</li>
<li>资源共享</li>
<li>相互制约</li>
<li>不可重现: 进程执行的结果不可重现</li>
</ul>
<p>进程与程序的区别</p>
<ul>
<li>程序是完成一项任务的代码序列</li>
<li>进程是一个程序的一次动态执行过程</li>
<li>程序是静态的; 进程是动态的</li>
<li>程序只包含代码; 进程包括要运行的代码、代码要处理的数据、运行过程中的参数等</li>
</ul>
<p>进程与程序的关联</p>
<ul>
<li>进程是操作系统为了管理控制程序的运行而加设的一个概念和实体</li>
<li>程序不运行就没有进程； 一个进程是一个程序的一次执行过程</li>
<li>一个程序可能对应多个进程<br><img src="/Pictures/作业程序进程.png" alt="作业程序进程"></li>
</ul>
<p>进程的特征</p>
<ul>
<li>动态特征：生命周期</li>
<li>并发特征：在一个时间段内都处在宏观的运行状态</li>
<li>独立特征：独立占有资源、独立参与CPU调度</li>
<li>异步特征：运行推进速度不可预知</li>
<li><p>结构特征：PCB(Process Contorl Block进程控制块)+进程体<br><img src="/Prictures/进程的组成.png" alt="进程的组成"></p>
<ul>
<li><p>进程控制块PCB的内容：<br><img src="/Pictures/进程控制块.png" alt="进程控制块"><br>进程控制块通常为结构体类型，包含进程的属性</p>
<ul>
<li>进程标识：系统识别进程的标志<ul>
<li>外部标识：进程的创建者提供的进程名字，通常由字符串组成</li>
<li>内部标识(PID)：系统为进程命名的一个代码，通常是一个整数</li>
</ul>
</li>
<li>进程调度信息：系统调度选择进程的依据<ul>
<li>进程优先数：描述进程紧迫性</li>
<li>进程状态信息：描述进程当前状态</li>
<li>其它调度信息：如：进程在系统中等待的时间、已在CPU上运行的时间、剩余的运行时间</li>
</ul>
</li>
<li><p>处理机信息(进程上下文) </p>
<p>进程被中断时，该进程的CPU现场信息可以保存在它自己的PCB内，以便该进程重新获得CPU时可以从此处回复现场信息，继续运行。 </p>
<ul>
<li>通用寄存器的内存：包括数据寄存器、段寄存器</li>
<li>程序状态字PSW(Program Status Word)的值</li>
<li>程序计数器PC(Program Count)的值</li>
<li>程序的堆栈指针</li>
</ul>
</li>
<li>进程控制信息：系统对进程实施控制的依据<ul>
<li>程序代码和数据集所在的内存地址</li>
<li>资源清单，记载进程请求资源和已经占有资源的情况</li>
<li>同步通信信息</li>
<li>外存地址</li>
<li>家族信息：父子进程</li>
<li>链接指针：跟当前PCB链接在同一队列的下一个PCB的地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>进程管理模块的主要功能</p>
<ul>
<li>进程控制<ul>
<li>管理控制一个进程的生命周期<ul>
<li>创建新进程，撤销结束进程</li>
<li>阻塞或唤醒进程</li>
<li>挂起或激活进程</li>
</ul>
</li>
<li>管理控制多个进程的并发<ul>
<li>进程同步和进程互斥</li>
<li>进程通信 </li>
</ul>
</li>
</ul>
</li>
<li>进程调度<ul>
<li>根据进程当前状态决定哪个进程获得CPU，以及占用多长时间</li>
<li>将CPU分给进程 </li>
</ul>
</li>
</ul>
<h2 id="进程的状态转换"><a href="#进程的状态转换" class="headerlink" title="进程的状态转换"></a>进程的状态转换</h2><p>系统的状态被管理为两种形式：运行态与非运行态，运行态为进程占用CPU时候的状态，其它情况下的进程都为非运行态<br><img src="/Pictures/两状态进程模型.png" alt="两状态进程模型"><br><img src="/Pictures/队列轮转图.png" alt="队列轮转图"></p>
<p>进程的三种基本状态：</p>
<ul>
<li>运行状态，进程获得CPU并投入运行的一种状态。在单CPU系统中，每个瞬间最多只能有一个进程在运行</li>
<li>就绪状态，进程尚未获得CPU使用权的一种状态。进程已经拥有除CPU外其它全部所需资源</li>
<li>阻塞状态，进程因为某种要求得不到满足，只好等待，称为运行受阻。处于阻塞状态的进程不配获得CPU<br><img src="/Pictures/三状态基本模型.png" alt="三状态基本模型"><br>进程的生存空间为作业驻留状态<br><img src="/Pictures/状态转换.png" alt="状态转换"></li>
<li><p>两种扩展的挂起状态</p>
<p>挂起：将内存中当前某个尚不能运行的进程调到外存上，腾出来空间接纳更多的进程。这一处理称为进程挂起(Suspend)。<br>挂起某些暂时不能运行的进程，目的是腾出内存装入更多进程，使CPU忙碌起来</p>
<ul>
<li>挂起阻塞状态(S-Blocked)</li>
<li>挂起就绪状态(S-Ready)<br><img src="/Pictures/一个挂起状态.png" alt="一个挂起状态"><br><img src="/Pictures/两个挂起状态.png" alt="两个挂起状态"></li>
</ul>
</li>
<li>PCB队列结构<br>  <img src="/Pictures/PCB队列结构.png" alt="PCB队列结构"> </li>
</ul>
<h3 id="进程状态转换原语"><a href="#进程状态转换原语" class="headerlink" title="进程状态转换原语"></a>进程状态转换原语</h3><ul>
<li>进程从残生到消亡的整个过程中都是有操作系统来控制的。</li>
<li>操作系统中实现进程控制的功能程序称为“原语”：机器指令构成的一种实现特定功能的小程序，它的运行具有不可分割性。<ul>
<li>贴近底层</li>
<li>最重要的</li>
<li>运行过程具有原子性（不可中断）</li>
<li>系统小程序 </li>
</ul>
</li>
<li>操作系统中的原语类别<br><img src="/Pictures/进程控制原语.png" alt="进程控制原语"><br><img src="/Pictures/原语类别.png" alt="原语类别"><h3 id="创建与撤销原语"><a href="#创建与撤销原语" class="headerlink" title="创建与撤销原语"></a>创建与撤销原语</h3></li>
<li>进程创建原语<ul>
<li>何时运行<br><img src="/Pictures/创建原语运行.png" alt="创建原语运行"></li>
<li>如何运行<br><img src="/Pictures/如何运行.png" alt="如何运行"><br><img src="/Pictures/创建原语2.png" alt="创建原语2"><br><img src="/Pictures/创建原语3.png" alt="创建原语3"><br><img src="/Pictures/创建原语4.png" alt="创建原语4"></li>
</ul>
</li>
<li>进程撤销原语<ul>
<li>何时运行<br><img src="/Pictures/何时撤销.png" alt="何时撤销"> </li>
<li>如何运行<br><img src="/Pictures/撤销运行.png" alt="撤销运行"><br><img src="/Pictures/撤销原语2.png" alt="撤销原语2"><br><img src="/Pictures/撤销原语3.png" alt="撤销原语3"><h3 id="阻塞与唤醒原语"><a href="#阻塞与唤醒原语" class="headerlink" title="阻塞与唤醒原语"></a>阻塞与唤醒原语</h3></li>
</ul>
</li>
<li>阻塞原语<ul>
<li>何时运行<ul>
<li>当正在运行的程序需要等待某一事件而发生运行受阻时，它通过中断请求系统服务</li>
<li>系统按照进程的需求进行适当处理后，启动“进程阻塞原语”将该进程阻塞起来 </li>
<li>引起进程阻塞的原因<ul>
<li>等待I/O</li>
<li>请求资源得不到满足</li>
<li>进程同步约束</li>
<li>服务进程无事可做 </li>
</ul>
</li>
</ul>
</li>
<li>如何运行<br><img src="/Pictures/阻塞原语的运行.png" alt="阻塞原语的运行"> </li>
</ul>
</li>
<li>唤醒原语<ul>
<li>何时运行<ul>
<li>当系统发生某一个事件时，正在等待该事件的进程需要立即被唤醒，由“阻塞”状态转为就绪状态</li>
<li>进程被唤醒的原因<ul>
<li>所等待的I/O操作已完成</li>
<li>请求的资源得到了满足</li>
<li>进程同步约束已撤销</li>
<li>服务进程收到新的任务  </li>
</ul>
</li>
</ul>
</li>
<li>如何运行–唤醒原语Wake_up()<ul>
<li>将当前进程的上下文保存到系统栈中（让现在正在占用CPU的当前进程暂时停下来）</li>
<li>从阻塞队列上查找等待该时间的进程PCB</li>
<li>将PCB从阻塞队列上摘下来</li>
<li>将其状态设置为“就绪”，将PCB挂入就绪队列</li>
<li>弹出系统栈中的进程上下文，置入CPU，让被中断的进程恢复运行</li>
<li>结束<h3 id="挂起与激活原语"><a href="#挂起与激活原语" class="headerlink" title="挂起与激活原语"></a>挂起与激活原语</h3></li>
</ul>
</li>
</ul>
</li>
<li>挂起原语<ul>
<li>何时运行<ul>
<li>当内存空间紧缺，部分进程有限运行</li>
<li>应用户的要求，将用户进程挂起</li>
<li>应父进程的要求，将子进程挂起</li>
</ul>
</li>
<li>如何运行–挂起原语Suspend()<ul>
<li>找到被挂起进程的PCB，获得其内存地址，将内控空间归还给存储管理模块</li>
<li>进程状态，阻塞转为“挂起阻塞”，或者就绪转为“挂起就绪”，将PCB从原队列转入相应的挂起队列</li>
<li>申请外存交换区空间，换出进程，将外存交换区所在的地址写入PCB</li>
<li>结束</li>
</ul>
</li>
</ul>
</li>
<li>激活原语<ul>
<li>何时运行<ul>
<li>有进程运行完毕，当前内存空间并不紧张</li>
<li>应用户要求，将其进程激活</li>
<li>应父进程的要求，将其子进程激活</li>
<li>进程自身设定的挂起周期已完成</li>
</ul>
</li>
<li>如何运行–激活原语Active()<ul>
<li>扫描“挂起就绪队列”（优先扫描挂起就绪队列，也可以扫描阻塞队列）也找到被激活进程的PCB</li>
<li>将PCB从所在的队列上摘下来</li>
<li>按PCB登记的时间需求，申请内存，加载到内存中</li>
<li>归还外存交换区空间</li>
<li>将进程状态置为“就绪”，插入就绪队列</li>
<li>结束</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="父进程与子进程"><a href="#父进程与子进程" class="headerlink" title="父进程与子进程"></a>父进程与子进程</h2><ul>
<li>fork()函数<br><img src="/Pictures/fork函数.png" alt="fork函数"><br><img src="/Pictures/fork返回值.png" alt="fork返回值"><br><img src="/Pictures/fork失败返回.png" alt="fork失败返回"><br><img src="/Pictures/测试fork返回值.png" alt="测试fork返回值"></li>
<li>提醒<ul>
<li>UNIX中，父进程通过系统调用fork()创建子进程，子进程继承父进程资源，父子进程各自独立</li>
<li>父子进程各自拥有自己的PCB、内存用户区、临时资源等，各自独立参与CPU调度，即父子进程的运行是异步的 </li>
</ul>
</li>
</ul>
<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ul>
<li>进程调度功能：从处于就绪状态的进程中，按照某种调度策略，选择一个进程切换给CPU，使其状态从就绪转为运行</li>
<li>调度方式<ul>
<li>非抢占式调度：当前进程主动放弃CPU的使用权<ul>
<li>进程运行完毕退出</li>
<li>运行受阻</li>
<li>运行出错，非正常终止</li>
<li>遇到不可挽回的故障</li>
</ul>
</li>
<li>抢占式调度<ul>
<li>也称剥夺式调度，一般用于有实时需求的系统。</li>
<li>主要指在系统正常运行期间，如果某种事件出现，系统将<strong>迫使正在运行的进程停下来</strong>，将CPU控制权交给其它进程。</li>
<li>其思想源自对高紧迫度作业的相应。</li>
</ul>
</li>
</ul>
</li>
<li>调度策略（调度算法）<ul>
<li>FCFS(First Come First Served)算法，先来先服务。先进入就绪队列的进程先调度</li>
<li>SPF(Shortest Process First)算法，短进程优先调度</li>
<li>HPF(Highest Priority First)算法，最高优先级调度</li>
<li>HRF(Highest Response First)算法，高响应比优先调度。</li>
<li>STR(Shortest Remain Time)算法，最短剩余时间优先算法。通常使用与实时系统中对于周期任务的调度</li>
<li>RR（Round Robin)算法，时间片轮转调度算法：<ul>
<li>将CPU的使用时间划分为多个时间片，各个并发进程轮流使用CPU，各使用一个时间片，时间片用完管理程序停止它的运行，并将它转入就绪队列尾部，调用下一个进程</li>
<li>应用于分时系统，目标是提高响应及时性</li>
<li>启动时机：<ul>
<li>一个时间片运行结束</li>
<li>当前进程运行结束</li>
<li>正在运行的进程因运行受阻主动放弃了CPU控制权</li>
</ul>
</li>
<li>时间片的选取<ul>
<li>进程的道数较多时，q就选得小一些；反之，可选得大些</li>
<li>系统要求的响应时间比较苛刻的时候，q就选得小一些，反之，可选得大一些。</li>
</ul>
</li>
</ul>
</li>
<li>多级队列调度算法<ul>
<li>设置多个就绪队列</li>
<li>就绪队列优先级不同，优先级高的队列优先调度</li>
<li>优先级高的队列空时，再调度低优先队列</li>
</ul>
</li>
<li>多级队列反馈调度算法<br><img src="/Pictures/多级队列反馈调度算法1.png" alt="多级队列反馈调度算法"><br><img src="/Pictures/多级队列反馈调度算法2.png" alt="多级队列反馈调度算法"><br>既照顾到短的进程，又照顾到长的进程，是一种性能比较好的进程调度算法</li>
</ul>
</li>
</ul>
<h2 id="实时系统的任务调度"><a href="#实时系统的任务调度" class="headerlink" title="实时系统的任务调度"></a>实时系统的任务调度</h2><ul>
<li><strong>实时任务</strong>是一类对时间要求较为严格的进程。支持这类任务运行的系统称为<strong>实时处理系统</strong>，分<strong>硬实时系统</strong>和<strong>软实时系统</strong></li>
<li>实时系统的调度方式一般是剥夺式（抢占式）的</li>
<li>非周期实时任务：不确定产生和停止的时间<ul>
<li>紧迫型：多见于专用的、响应时间要求特别苛刻的数据采集和控制系统中，所要求的相应时间一般是微秒级的。采用“<strong>立即抢占调度算法</strong>（HPF）。<br><img src="/Pictures/立即抢占.png" alt="立即抢占"> </li>
<li>普通型：对相应时间的要求不是太高，一般是毫秒级的。由于它允许相应时间长度与时钟中断的周期基本吻合，一般采用“<strong>基于时钟中断抢占的高优先级调度算法</strong>”<br><img src="/Pictures/基于时钟中断抢占.png" alt="基于时钟中断抢占"> </li>
<li>宽松型：要求的响应时间比较长，一般可达数百毫秒甚至数秒钟。采用的调度算法也有多种：<ul>
<li>非抢占的优先级调度算法（HPF）<br><img src="/Pictures/非抢占的优先级调度算法.png" alt="非抢占的优先级调度算法"> </li>
<li>时间片轮转算法（RR）<br><img src="/Pictures/时间片轮转算法.png" alt="时间片轮转算法"> </li>
</ul>
</li>
</ul>
</li>
<li>周期实时任务：信号检测和过程控制系统中呈现周期性运行规律的任务<br><img src="/Pictures/周期性实时任务.png" alt="周期性实时任务"><ul>
<li>最小剩余时间调度算法（SRT）</li>
</ul>
</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>一个进程运行过程中可创建多个线程，线程共享所属进程的资源，自己只有线程控制块（TCB）和很少的栈区</p>
<ul>
<li>线程的描述：<ul>
<li>线程是现代操作系统引入的一种执行实体</li>
<li>线程称“轻型进程”，是进程的组成成分</li>
<li>进程是资源占有单位，线程只是CPU调度单位，即执行单位</li>
</ul>
</li>
<li>多线程进程模型<br><img src="/Pictures/多线程进程模型.png" alt="多线程进程模型"></li>
<li>多线程结构进程的优点<ul>
<li>快速线程切换</li>
<li>通信易于实现</li>
<li>减少管理开销</li>
<li>并发程度提高</li>
</ul>
</li>
<li>线程的分类：内核级线程KTL和应用级线程UTL<br><img src="/Pictures/线程的分类.png" alt="线程的分类"> <ul>
<li>KTL:由操作系统的系统程序创建，系统可见。管理、控制、调度都是由操作系统完成</li>
<li>UTL：由用户程序创建、管理、调度，用户可见。</li>
</ul>
</li>
<li>进程与线程的区别<ul>
<li>进程是一个独立的实体单位：<ul>
<li>独占资源</li>
<li>独立参与调度/执行</li>
</ul>
</li>
<li>线程仅是分派（调度运行）的单位</li>
<li>线程不是单独占有资源的单位。线程共享其所属进程的资源</li>
<li>操作系统<strong>引入进程</strong>的目的是为了多个程序并发执行，以改善资源使用率和提高系统效率</li>
<li>操作系统<strong>引入线程</strong>的目的是为了减少并发执行时所付出的时空开销，是的并发粒度更细、并发性更好 </li>
</ul>
</li>
</ul>
<h2 id="处理机的四级调度"><a href="#处理机的四级调度" class="headerlink" title="处理机的四级调度"></a>处理机的四级调度</h2><ul>
<li>调度的主要目标：选择哪个实体进入内存、选择哪个实体占用CPU</li>
<li>调度的主要层次：作业调度、进程调度、中级调度、线程调度</li>
<li>三级调度：<ul>
<li>高级调度：又称作业调度、长程调度。从处于后备状态的作业中选择一道或几道，装入内存。只有批作业会进入高级调度</li>
<li>中级调度：又称中程调度。优先从处于挂起就绪状态的进程中选择一个或几个，将其激活</li>
<li>低级调度：又称进程调度、短程调度。从处于就绪状态的进程中选择一个，切换给CPU执行<br><img src="/Pictures/三级调度.png" alt="三级调度"> </li>
</ul>
</li>
<li>四级调度：在三级调度的基础上加了进程调度<ul>
<li>用户级线程的调度<br><img src="/Pictures/用户级线程调度.png" alt="用户级线程调度"> <ul>
<li>操作系统进行进程调度</li>
<li>用户程序进行线程调度</li>
</ul>
</li>
<li>内核级线程的调度<br><img src="/Pictures/内核级线程调度.png" alt="内核级线程调度"><br>操作系统直接进程线程调度</li>
</ul>
</li>
<li>线程与子进程调度的区别<br><img src="/Pictures/线程与子进程调度的区别.png" alt="线程与子进程调度的区别"> </li>
</ul>
<h2 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h2><ul>
<li>互斥：允许多个进程共享资源，但是多个进程不能同时获取和使用资源。体现进程之间的竞争关系</li>
<li>同步：允许多个进程共享资源，但是多个进程不能同时使用，而且使用顺序也有严格的约束</li>
<li>并发：<ul>
<li>单处理器多道程序设计中，多个进程交替执行</li>
<li>多个并发进程在一个时间段内都处于运行状态</li>
<li>共享系统资源</li>
<li>每个进程都“走走停停”</li>
<li>并发带来异步性：每个进程在某一时刻的运行状态都不确定</li>
</ul>
</li>
<li>并发带来的问题<ul>
<li>并发进程的相对执行速度不可预测</li>
<li>可能会发生各种与时间有关的错误</li>
</ul>
</li>
<li>临界资源（Critical Resources）：也叫互斥资源，一次只能为一个进程服务的共享资源。<ul>
<li>临界区：进程体重使用临界资源的代码段</li>
<li>相关临界区：使用同一临界资源的的不同的代码段</li>
</ul>
</li>
<li>与并发相关的关键术语<ul>
<li>互斥：当一个进程在进阶区进行时，使用临界资源，其它进程不能进入相关临界区。体现竞争关系</li>
<li>同步：不但不能同时使用临界资源，还得有严格的先后使用顺序。体现协作关系</li>
<li>死锁：两个或两个以上的进程，因为其中的每个进程都在等待其它进程做完某些事情，而整体不能继续执行，所有进程永远阻塞等待</li>
<li>活锁：两个或两个以上的进程，为了响应其它进程中的变化而持续改变自己的状态，但不做有用的工作</li>
<li>饥饿：一个可运行的进程被调度程序无限地忽略，不能被调度的情形</li>
<li>原子操作：保证指令序列要么作为一个组来执行，要么都不执行</li>
</ul>
</li>
<li>操作系统在管理和控制资源分配方面，应当保证进程对临界资源的访问满足：<ul>
<li>互斥访问</li>
<li>不至于产生“死锁”</li>
<li>不能有“饥饿”进程</li>
</ul>
</li>
</ul>
<h2 id="解决进程互斥"><a href="#解决进程互斥" class="headerlink" title="解决进程互斥"></a>解决进程互斥</h2><ul>
<li>互斥管理准则<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待</li>
<li>让权等待</li>
</ul>
</li>
<li>软件方法解决进程互斥：实际上是失败的，现代操作系统中不再使用</li>
<li>信号量机制解决进程互斥<ul>
<li>基本原理：<ul>
<li>两个或多个进程通过简单的信号进行合作</li>
<li>任何复杂的合作需求都可以通过适当的信号结构得到满足</li>
</ul>
</li>
<li>实现要素<ul>
<li>信号量（Semaphore结构体类型，内含一个阻塞队列和一个整型值）</li>
<li>P操作原语（wait）：执行进程进入临界区之前的检查操作</li>
<li>V操作原语（signal）：进程出临界区时释放资源</li>
</ul>
</li>
<li>解决互斥<ul>
<li>一种CR设一个信号量，根据临界资源的种类来设置</li>
<li>信号量的初值设置为<strong>系统初始状态CR允许几个进程使用</strong></li>
<li>P操作用于临界区前，相当于进入CS之前申请CR</li>
<li>V操作用于临界区前，相当于出之后释放CR</li>
<li>P、V操作必须成对匹配</li>
</ul>
</li>
<li>互斥信号量的值(semaphore mutex: value)：<ul>
<li>>= 1 目前临界资源有mutex.value个可用</li>
<li>== 0 目前临界资源没有可用的</li>
<li>&lt;= 0 目前有|mutex.value|个进程因等待该临界资源而阻塞</li>
</ul>
</li>
<li>解决同步<ul>
<li>一种CR设一个信号量，根据需要的同步信号来设置</li>
<li>信号量的初值设置为<strong>系统初始状态下信号的有无</strong></li>
<li>P操作用于临界区前，相当于检查同步信号</li>
<li>V操作用于临界区前，相当于让出同步信号</li>
<li>P、V操作<strong>不必</strong>成对匹配</li>
</ul>
</li>
<li>同步信号量的值(semaphore s: value)：<ul>
<li>>= 1 目前有s.value个s对应的同步信号</li>
<li>== 0 目前没有s对应的同步信号</li>
<li>&lt;= 0 目前有|s.value|个进程因等待s对应的同步信号而阻塞</li>
</ul>
</li>
<li>同步和互斥操作临界区重合时遵循的原则：<strong>同步在外，互斥在内</strong></li>
<li>信号量集机制<ul>
<li>一个P操作，可以同时申请多个临界资源</li>
<li>一个V操作，可以同时释放多个临界资源</li>
</ul>
</li>
</ul>
</li>
<li>管程机制<ul>
<li>管程是由局部数据结构、多个处理过程和一套初始化代码组成的模块。是一种具有<strong>面向对象</strong>程序设计思想的同步机制。提供了与信号量机制相同的功能。</li>
<li>管程结构模型<br><img src="/Pictures/管程结构模型.png" alt="管程结构模型"> </li>
<li>管程的特征<ul>
<li>管程内的数据结构只能被管程内的过程访问，任何外部访问都是不允许的</li>
<li>进程可以通过调用管程的一个过程进入管程</li>
<li>任何时间只允许一个进程进入管程，其他要求进入管程的线程统统被阻塞到等待管程的队列上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个或两个以上的进程，因为其中的每个进程都在等待其它进程做完某些事情，而整体不能继续执行，所有进程永远阻塞等待</p>
<ul>
<li>死锁产生的原因：<ul>
<li>动态资源分配策略</li>
<li>资源可用数量少于需求数量</li>
<li>进程并发过程的偶然因素</li>
<li>因为有偶然性，所以无法给出死锁产生的充分条件</li>
</ul>
</li>
<li>死锁产生的四个必要条件<ul>
<li>互斥条件：进程请求的资源属于互斥(临界)资源，每一瞬间只能由一个进程使用，其它申请该资源的进程等待</li>
<li>不可剥夺条件：进程获得某资源后，便一直占有它，直到用完为止才可以释放，其它进程不可以剥夺</li>
<li>请求和保持条件：允许一个进程在保持已有资源不放弃的情况下，进一步请求新资源，被阻塞时也不会释放已有的资源</li>
<li>环路等待条件：一组进程{P1，……， Pn}的占有资源情况与请求资源情况构成了一个环形链。有死锁一定有环</li>
</ul>
</li>
<li>死锁的描述<ul>
<li>资源请求分配图<br> <img src="/Pictures/资源请求分配图.png" alt="资源请求分配图"></li>
<li>资源请求分配矩阵<br><img src="/Pictures/资源请求分配矩阵.png" alt="资源请求分配矩阵"><br><img src="/Pictures/资源请求分配矩阵2.png" alt="资源请求分配矩阵"><br><img src="/Pictures/资源请求分配矩阵3.png" alt="例子"></li>
</ul>
</li>
<li>死锁的解决办法<ul>
<li>事前处理：针对性采取措施，让死锁没有机会发生<ul>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
</li>
<li>事后处理：即时检测、即时解除<ul>
<li>死锁检测</li>
<li>死锁解除</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h2><ul>
<li>计算机的存储器层次结构<br><img src="/Pictures/存储器层次.png" alt="存储器层次"><br><img src="/Pictures/各级存储器性能.png" alt="各级存储器性能"></li>
<li>存储管理的管理目标<ul>
<li>内存的合理分配使用</li>
<li>提高内存利用率</li>
<li>程序、数据在内存中顺利读写</li>
<li>小内存运行大程序</li>
</ul>
</li>
<li><p>存储管理的管理功能</p>
<ul>
<li>内存的分配和回收：合理分配、即时回收</li>
<li><p>地址重定位（地址转换）：将逻辑地址转换成物理地址</p>
<ul>
<li>物理地址：存储单元的实际物理单元地址</li>
<li>逻辑地址：用户空间中使用的相对地址</li>
<li>静态重定位：地址转换工作在进程执行前一次性完成。无需硬件支持，易于实现，但不允许程序在执行过程中移动</li>
<li>动态重定位：地址转换推迟到进程执行时才完成。允许程序在主存中移动，便于主存共存，主存利用率高<br><img src="/Pictures/程序的编译链接装载和执行.png" alt="程序的编译链接装载和执行"></li>
</ul>
</li>
<li><p>地址共享和保护</p>
<ul>
<li>共享的含义<ul>
<li>共享内存储器资源，让多个进程同时进入内存区域，共享一个存储器</li>
<li>共享内存储器的某些区域，即允许两个或多个进程访问内存中同一段程序或数据</li>
</ul>
</li>
<li>地址保护的含义<ul>
<li>保护操作系统：用户进程不能访问或修改系统区</li>
<li>保护用户进程：用户进程不能访问或修改其它进程的用户区</li>
<li>保护方法<br><img src="/Pictures/保护方法.png" alt="保护方法"> </li>
</ul>
</li>
</ul>
</li>
<li>地址扩充：用存储管理软件来实现的逻辑扩充</li>
</ul>
</li>
</ul>
<h3 id="连续存储管理：一个进程装入连续的一块内存空间"><a href="#连续存储管理：一个进程装入连续的一块内存空间" class="headerlink" title="连续存储管理：一个进程装入连续的一块内存空间"></a>连续存储管理：一个进程装入连续的一块内存空间</h3><ul>
<li>单分区存储管理：内存用户区的全部空间只存放一个进程。只适用于单道系统<ul>
<li>CPU的利用率低</li>
<li>外部设备利用率低</li>
<li>内存空间浪费严重</li>
</ul>
</li>
<li><p>多分区方式：内存被分为多个分区，每个分区存放一个进程</p>
<ul>
<li><p>常用的数据结构：主存分配表MAT(Memory Allocation Table)</p>
<ul>
<li><p>主存分配表</p>
<ul>
<li>分区号：每个分区都有个编号，用以区分不同分区</li>
<li>起始地址：分区的起始地址，即首地址</li>
<li>长度：分区的总长，一般以KB为单位</li>
<li>占用标志：记录分区的使用状态，占用为0表示分区空闲，可以进行分配</li>
</ul>
</li>
<li><p>空闲分区表/链：记录内存空闲区状况的数据结构（MAT表的一个子表）,只包含空闲分区<br><img src="/Pictures/空闲分区表.png" alt="空闲分区表"></p>
<p>有空闲区链中各空闲区可按地址顺序排列，也可按尺寸大小来组织，当系统进行内存分配时，进行的处理是：</p>
<ul>
<li>通过空闲区链快速搜索内存的空闲区</li>
<li>从中找出最合适的分区分配出去</li>
<li>将该节点从链上删除 </li>
</ul>
<p>当需要回收某块被释放的区域时，系统处理过程为：</p>
<ul>
<li>按其地址或者大小在链中找到合适的位置</li>
<li>插入一个新节点，记录回收分区的起始地址和长度</li>
<li>若存在相邻的空闲区，需要的话可将相邻空闲区合并  </li>
</ul>
</li>
</ul>
</li>
<li><p>固定多分区：分区数目是固定的，每个分区的起始地址和长度固定。MAT表可用静态数组实现 </p>
<ul>
<li>内碎片：小进程装入大分区后的闲置内存空间。降低了内存的有效利用率，但不可避免</li>
<li>采用静态地址重定位</li>
<li>适用的主存分配算法：最佳适应算法(<strong>Best Fit</strong>)</li>
</ul>
</li>
<li>动态多分区：系统不预先划分固定分区，而是在装入进程时，根据进程的实际需求量划分出一个小分区给它适用。MAT分区表需要用动态数组来实现<ul>
<li>外碎片：零星的、因为太小不太容易被分配利用的小空闲区</li>
<li>主存分配算法只会讲分区越分越小，几乎都不适应</li>
<li>消除外碎片的方法： <ul>
<li>主存分配过程中，通过程序浮动将不相邻的空闲分区移为相邻的进行合并</li>
<li>回收过程中相邻空闲区进行合并</li>
</ul>
</li>
<li>动态多分区存储保护<br><img src="/Pictures/动态多分区存储保护.png" alt="动态多分区存储保护"> <ul>
<li>基址寄存器记录当前进程所占分区的首地址</li>
<li>限长寄存器记录当前进程的长度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>多分区主存分配算法：</p>
<ul>
<li><p>首次适应算法First_Fit</p>
<p>系统将内存分区按地址递增顺序登记到内存分配表（或空闲分区表）中，每次进行分配时，系统根据进程申请空间的大小，从头到尾扫描内存分配表（或空闲分区表），从中找到第一块满速要求的空闲区分配出去</p>
</li>
<li><p>循环首次适应算法Circle_First_fit</p>
<p>将内存中所有的空闲分区从低址到高址组成一个循环链表，每次分配时从上次分配的位置开始向尾部查找，查找到第一个可满足的空闲空间分配给用户。当查到表尾仍未找到则转到头部继续</p>
</li>
<li><p>最佳适应算法Best_Fit</p>
<p>从空闲区表中找打一块满足需求的最小空闲分区分配给用户</p>
</li>
<li><p>最坏适应算法Worse_Fit</p>
<p>从空闲区表中找打一块满足需求的最大空闲分区分配给用户</p>
</li>
</ul>
</li>
</ul>
<h3 id="非连续存储管理"><a href="#非连续存储管理" class="headerlink" title="非连续存储管理"></a>非连续存储管理</h3><ol>
<li><p>分页方式：内存被划分为多个等长的存储块，每个进程占用其中的若干块，整个内存允许有多个进程同时驻留</p>
</li>
<li><p>多段方式：对分段结构的应用程序，按照长度分贝位置分配内存空间</p>
</li>
<li><p>段页方式：在分段式管理的基础上加上分页式管理可形成段页式管理</p>
</li>
</ol>
<ul>
<li><p>基本分页存储管理</p>
<ul>
<li>内存被划分成大小固定相等的块(Frame帧、页框、主存块)，且块相对较小</li>
<li>每个进程装入时被分为同样大小的页(Page)，一页装入一帧。<ul>
<li>页面尺寸（长度）由计算机系统的硬件决定，一台机器只能规定一种尺寸。</li>
<li>目前流行的页面尺寸在1KB到4KB之间</li>
</ul>
</li>
<li><p>整个进程被离散装入到多个不连续的帧</p>
</li>
<li><p>记录内存使用情况的数据结构：位示图</p>
<p>整个系统一张图，记录内存的使用情况</p>
<p><img src="/Pictures/记录内存的数据结构.png" alt="记录内存的数据结构"> </p>
<ul>
<li>每一行代表一个字</li>
<li>每一列代表一个位</li>
<li>每个元素代表一个帧：0为空闲，1为占用</li>
<li>分配时，找到值为0的位，将值改为1，根据字号和位号换算出帧号，并记录</li>
<li>释放时，根据记录的帧号换算出字号和位号，将值从1改为0</li>
</ul>
</li>
<li><p>记录每个进程分页及占用内存情况的数据结构：分页表(PT)</p>
<p>登记进程各页面对应的帧号，供地址映射使用。记录该进程分了多少个页，每一页占用哪一个帧</p>
<p><img src="/Pictures/页表示例.png" alt="页表示例"></p>
<ul>
<li>页面分配算法</li>
</ul>
<ol>
<li>计算请求者需要的总帧数N</li>
<li>查位图，若找不到足够的空闲帧，返回分配失败</li>
<li>索取一个空闲页表PT</li>
<li>从位图中找出N个0位，计算出对应的帧号，填入PT</li>
<li>在位示图将这些为改为1</li>
<li>将PT其实地址填入进程的PCB中</li>
</ol>
</li>
<li><p>地址划分</p>
<ul>
<li>进程装入之前，逻辑地址是一维的</li>
<li>进程装入（分页）之后，逻辑地址分为二维：页号和页内偏移量（页内地址）</li>
<li>地址划分例子<br><img src="/Pictures/地址划分.png" alt="地址划分"></li>
<li>地址重定位<br><img src="/Pictures/地址重定位.png" alt="地址重定位">  </li>
<li>地址保护<br><img src="/Pictures/地址保护.png" alt="地址保护"> </li>
</ul>
</li>
<li>总结：<ul>
<li>离散存储，利于大进程装入</li>
<li>只有很少的页内碎片，每个进程只有最后一页可能占不满整个帧，提高内存利用率</li>
</ul>
</li>
</ul>
</li>
<li><p>基本分段存储管理</p>
<ul>
<li>“段”是一个逻辑单位，是进程的一个组成部分。如主程序段、子程序段、数据段等</li>
<li>原理<ol>
<li>进程的程序和其相关的数据按逻辑分段</li>
<li>段有一个最大长度限制，但不要求所有程序的所有段的长度都相等</li>
<li>一段一段占用一块连续存储区</li>
<li>各段占用不连续分区，实现离散存储</li>
</ol>
</li>
<li>记录内存使用情况的数据结构：<ul>
<li>MAT</li>
<li>空闲分区表/链</li>
<li>这里的MAT与动态多分区中MAT表的异同：<ul>
<li>相同点：MAT的一个表项对应内存一个分区</li>
<li>不同点：分区中存放的内容不同<ul>
<li>动态多分区中，一个分区存放一整个进程</li>
<li>分段存储中，一个分区存放进程的一个段。一个进程离散成多个段装入多个不连续的分区</li>
</ul>
</li>
</ul>
</li>
<li>记录各个进程分段情况的数据结构<ul>
<li>段表ST(Segment Table)，为每个进程设置一张段表，用来记录各个段地址映射的关系<ul>
<li>进程分了几段，段表就有几个表项</li>
<li>一个表项记录一个分段在内存空间中的存储地址和长度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>地址重定位<br><img src="/Pictures/地址重定位1.png" alt="地址重定位"> </li>
<li>分段保护<ul>
<li>第一级保护是防止进程发生超出存储空间的访问</li>
<li>第二级保护是组织进程超出访问权限的读写</li>
<li><img src="/Pictures/分段保护.png" alt="分段保护"><ul>
<li>S表示段号</li>
<li>d表示段内偏移</li>
</ul>
</li>
</ul>
</li>
<li>段面共享：<ul>
<li>将内存中共享段的起始地址以及长度填入需要共享的用户进程的段表中 </li>
<li>共享段表SST(Sharing Segment Table)：记载各个共享段的使用情况，任何一个进程调用共享段时，系统都将访问该表<br><img src="/Pictures/共享段表实例.png" alt="共享段表实例"></li>
</ul>
</li>
</ul>
</li>
<li><p>基本段页式存储管理</p>
<ul>
<li>分页与分段：<ul>
<li>分页：<ul>
<li>有利于大进程装入，内存利用率高</li>
<li>页是物理页，页面共享不易实现</li>
</ul>
</li>
<li>分段：<ul>
<li>段是逻辑段，方便实现分段共享</li>
<li>外碎片的存在降低内存的使用效率，且整理消除外碎片会加大系统开销</li>
</ul>
</li>
</ul>
</li>
<li>段页式：<ul>
<li>内存划分成大小相等的页框（帧）</li>
<li>用户的地址空间划分为多个段，每个段按照帧的大小一次划分成多个固定大小的页，页的长度等于内存中的页框大小</li>
</ul>
</li>
<li>记录内存使用情况的数据结构<ul>
<li>位示图，记录内存各帧是否占用</li>
<li>段表，记录各个分段对应段页表的地址和长度</li>
<li>段内页表，记录该段划分为多少页，每页分配的帧号是多少<br><img src="/Pictures/段表和段内页表.png" alt="段表和段内页表"> </li>
</ul>
</li>
<li>地址形式：<ul>
<li>处理器内部的硬件支持：段表控制寄存器、地址生成逻辑</li>
</ul>
<ol>
<li>程序中的逻辑地址仍然是二维地址：&lt;段号， 偏移量&gt;</li>
<li>每段装入时分页，地址部分被当作三维地址类处理：&lt;段号，页号，页内偏移&gt; </li>
</ol>
</li>
<li>段页式地址重定位<br><img src="/Pictures/段页式地址重定位.png" alt="段页式地址重定位">  </li>
<li>段页式地址保护<br><img src="/Pictures/段页式地址保护.png" alt="段页式地址保护"> </li>
<li>段页式地址字结构的计算<br><img src="/Pictures/段页式地址字结构的计算.png" alt="段页式地址字结构的计算"></li>
</ul>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        
<div class="counter-tag counter">
    <span id="/2020/03/16/操作系统/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="操作系统">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-UnicodeProgramming" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/16/UnicodeProgramming/" class="article-date">
  	<time datetime="2020-03-16T07:39:55.000Z" itemprop="datePublished">2020-03-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/16/UnicodeProgramming/">
        Unicode note
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从ASCII到16位UCS-2再到完全Unicode的过渡期间，大多数编程语言都笨拙地发展了。它们包含了国际化的功能，但是这些功能通常无法移植或无法满足需求。</p>
<p>Unicode不仅仅是每种语言字符的编码方案，还包括字符大小写、方向性和字母属性。Unicode标准和规范描述了划分单词和断行、对文本排序、设置数字格式、在不同方向显示文本、分割/合并/重新排列南亚语言元音字母的正确方法，以及确定什么时候字符在视觉上看起来容易混淆。</p>
<p>人类的语言千差万别，内部不一致，任何将字符串视为不透明字节流的应用程序都必须具有复杂性。实际上，这意味着使用成熟的第三方库。</p>
<p>本文通过示例程序说明了文本处理的想法。我们将使用成熟的，可移植的Unicode国际组件（ICU）库，它为许多产品和操作系统背后的国际文本处理提供支持。</p>
<p>IBM（ICU的维护者）正式支持C，C ++和Java API。我们将在这里使用C API更好地了解内部原理。许多语言都有与库的绑定，因此这些概念应适用于您选择的语言。</p>
<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><ul>
<li><a href="#1">什么是“字符”？</a></li>
<li><a href="#2">字形与字形</a></li>
<li><a href="#3">代码点如何编码？</a></li>
<li><a href="#4">应该选择哪种编码？</a></li>
</ul>
<h3 id="什么是字符？"><a href="#什么是字符？" class="headerlink" title="什么是字符？"></a><span id="1">什么是字符？</span></h3><p>“字符”是一个重载术语。语言的母语者将其标识为字母或符号的内容通常存储为内部Unicode表示形式中的多个值。内存，磁盘或网络传输期间的附加编码进一步掩盖了该表示。</p>
<p>让我们从最接近用户的抽象开始：字素簇。“字素”是被读者识别为书写系统的单个元素的图形单元。也就是用户认识的字符。例如，山，ä和క్క是字素。单个字素的各个部分始终保持在一起打印。将它们分开是荒谬的或是改变了符号的含义。它们被渲染为“字形”，即在纸或屏幕上的标记随字体，样式或单词中的位置而变化。</p>
<p>您可能会想像到Unicode为每个字素分配一个唯一的数字，但这是不正确的。这样造成浪费，因为字母和变音符号之间会组合爆炸。例如（o，ô，ọ，ộ）和（a，â，ạ，ậ）遵循一个模式。与其给每个数字分配一个不同的数字，不如给o和a分配一个数字，然后给每个组合标记分配一个数字，效率更高。字素可以由字母和组合标记构成，例如ậ= a + ◌̂ +◌̣ 。</p>
<p>实际上，Unicode采用两种方法。它将数字分配给基本字母和组合标记，但也分配一些更常见的组合。因此，可以以多种方式创建许多字素。例如，ộ可以通过五种方式指定：</p>
<pre><code>* A：U + 006f（o）+ U + 0302（◌̂ ）+ U + 0323（◌̣ ）
* B：U + 006f（o）+ U + 0323（◌̣ ）+ U + 0302（◌̂ ）
* C：U + 00f4（ô）+ U + 0323（◌̣ ）
* D：U + 1ecd（ọ）+ U + 0302（◌̂ ）
* E：U + 1ed9（ộ）
</code></pre><p>每个抽象字符和每个组合符号的数字（写为U + xxxx）称为“代码点”。每个Unicode字符串都表示为代码点列表。如上所述，多个代码点串可以呈现为相同的字素序列。</p>
<p>为了有意义地比较每个编码点的字符串是否相等，两个字符串都应以一致的方式表示。字素的码点分解的标准选择称为“范式”。</p>
<p>一种选择是将字符串分解为尽可能多的代码点，例如示例A和B（其权重因子应首先包含组合标记）。这就是所谓的规范化形式规范分解（NFD）。另一种选择是进行相反操作，并使用尽可能少的代码点，例如示例E。这称为规范化形式规范组合（NFC）。</p>
<p>要记住的一个核心概念是，尽管代码点是文本的构建块，但它们与用户感知的字符（字素）不一一匹配。诸如获取代码点数组的长度或访问任意数组位置之类的操作通常对Unicode程序没有用。插入或删除代码点时，程序还必须注意组合字符，例如变音符号。将U + 0061插入星号位置U + 006f U + 0302（*）U + 0323将字符串“ộ”更改为“ôạ”而不是“ộa”。</p>
<h3 id="字形与字形"><a href="#字形与字形" class="headerlink" title="字形与字形"></a><span id="1">字形与字形</span></h3><p>导致字形被渲染为不同字形的不仅仅是字体。某些语言的规则会导致字形通过上下文整形而改变。例如，阿拉伯字母“ heh”具有四种形式，具体取决于字母两侧。孤立时，它显示为ﻩ，在单词的最终/初始/中间位置分别显示为ﻪ / ﻫ / ﻬ。同样，希腊文在小数位sigma（单词的最后一个形式）的显示方式不同于其他地方。一些字形根据视觉顺序而变化。在从右到左的语言中，起始括号“（”镜像显示为“）”。</p>
<p>不仅单个字形的字形变化，而且字形可以组合形成单个字形。一种方法是通过连字。拉丁字母“ fi”通常将i的点与f的曲线连接起来（表示形式为U + FB01 fi）。另一种方法是语言不规范。阿拉伯语的ا和ل连续时，必须形成ﻻ。</p>
<p>相反，单个字形可以拆分为多个字形。例如，在某些印度语言中，元音可以拆分并包围前面的辅音。在孟加拉语中，U + 09CC s包围U + 09AEম成为মৌ。尝试将光标置于此文本框的末尾并按Backspace键：<br>মৌ</p>
<h3 id="代码点如何编码？"><a href="#代码点如何编码？" class="headerlink" title="代码点如何编码？"></a><span id="1">代码点如何编码？</span></h3><p>在1990年，Unicode代码点为16位宽。对于人们想要代表的符号和语言来说，这种选择实在是太小了，因此委员会将该标准扩展到21位。从抽象上讲没关系，但是这21位如何存储在内存中或在计算机之间进行通信取决于实际因素。</p>
<p>这是一个异常的内存大小。计算机硬件通常不以21位块的形式访问内存。网络协议也更适合一次传输八位。因此，代码点被分解成更常规大小的块序列，称为代码单元，以便在磁盘上持久化，通过网络传输以及在内存中进行操作。</p>
<p>Unicode转换格式（UTF）描述了在代码点和代码单元之间映射的不同方法。转换格式以其代码单位（7、8、16或32）的位宽以及字节序（BE或LE）命名。例如：UTF-8或UTF-16BE。除了UTF外，还有另一种（更复杂的）编码称为Punycode。它旨在符合用于Internet主机名的有限ASCII字符子集。</p>
<p>最后一点术语。“平面”是65,536个代码点的连续组。有17个平面，由数字0到16标识。平面0是基本多语言平面（BMP），其中包含最常用的字符。较高的平面（1到16）称为“补充平面”。</p>
<h3 id="应该选择哪种编码？"><a href="#应该选择哪种编码？" class="headerlink" title="应该选择哪种编码？"></a><span id="1">应该选择哪种编码？</span></h3><p>对于传输和存储，请使用UTF-8。移动ASCII数据的程序无需修改即可对其进行处理。机器字节序不影响UTF-8，并且字节大小的单元在网络和文件系统中运行良好。</p>
<p>某些站点（例如UTF-8 Everywhere）走得更远，建议使用UTF-8对程序存储器中的文本进行内部操作。但是，我建议您使用Unicode库支持的任何编码方式。您将通过库API而不是直接在代码单元上执行操作。正如我们所看到的，字形，字素，代码点和代码单元之间的复杂性太高，无法直接操作这些单元。使用您的库首选的编码，并在程序边缘将UTF-8转换为UTF-8。</p>
<p>使用UTF-32将字符串存储在内存中是不明智的。在这种编码中，每个代码单元可以容纳一个完整的代码点是正确的。但是，代码点和字形之间的关系并不简单，因此以这种方式存储字符串没有编程优势。</p>
<p>UTF-32还浪费每个代码点最少11（32-21）位，并且通常浪费更多。例如，UTF-16只需一个16位代码单元即可在基本多语言平面中编码点（最常遇到的点）。因此，UTF-32通常可以使BMP所需的空间增加一倍。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        
<div class="counter-tag counter">
    <span id="/2020/03/16/UnicodeProgramming/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="Unicode note">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-CUDA" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/03/15/CUDA/" class="article-date">
  	<time datetime="2020-03-15T08:05:02.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/15/CUDA/">
        CUDA学习记录
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CUDA-Learning-Record"><a href="#CUDA-Learning-Record" class="headerlink" title="CUDA Learning Record"></a>CUDA Learning Record</h2><p>随着显卡的发展,GPU越来越强大,在计算上已经超过了通用的CPU.为了更大限度的利用GPU的运算能力,NVIDIA推出CUDA, 使得显卡可以用与图像计算之外的目的.</p>
<h3 id="CPU-GPU异构并行计算架构"><a href="#CPU-GPU异构并行计算架构" class="headerlink" title="CPU+GPU异构并行计算架构"></a>CPU+GPU异构并行计算架构</h3><p>CPU与GPU是两个独立的处理器，之间通过PCIe总线相连。GPU不是一个独立的运行平台，而是CPU的一个协处理器。CPU所在位置称为主机端(host)，GPU所在位置称为设备端(device)</p>
<ol>
<li>评价GPU的指标<br>描述GPU容量的两个重要特征：</li>
</ol>
<ul>
<li>CUDA核心数量</li>
<li>内存大小</li>
</ul>
<p>相应的，评价GPU性能的两种指标：</p>
<ul>
<li>峰值计算性能</li>
<li>显存带宽</li>
</ul>
<p>峰值计算性能用来评估计算容量，通常定义为每秒能够处理的单精度或双精度浮点运算的数量。单位通常为GFlops(每秒十亿次运算)或TFlops(每秒万亿次运算)。<br>显存带宽是从内存中读取或写入数据的比率。单位通常为GB/s。</p>
<ol start="2">
<li>CPU与GPU的线程与核心</li>
</ol>
<p>CPU的线程通常是重量级的实体，操作系统必须交替线程，启用或关闭CPU执行通道，以提供多线程处理功能，上下文切换缓慢且开销大。</p>
<p>GPU的线程是高度轻量级的，在一个典型的系统中会有成千上万的线程排队等待工作。</p>
<p>CPU的核心被设计为尽可能减少一个或两个线程运行时间的延迟</p>
<p>GPU的核心是用来处理大量并发的、轻量级的线程，以最大限度地提高吞吐量</p>
<ol start="3">
<li>CPU+GPU异构</li>
</ol>
<p>CPU具有处理复杂逻辑和指令级并行的能力   </p>
<p>GPU中有大量可编程核心，可支持大规模多线程运算，且相比CPU有更大的峰值带宽。   </p>
<p>CPU+GPU的异构并行计算架构利用CPU和GPU的功能互补性，使得程序能够获得最佳的运行效果。<br>在CPU上执行串行部分或任务并行部分，在GPU上执行数据密集型并行部分。</p>
<h3 id="CUDA编程模型"><a href="#CUDA编程模型" class="headerlink" title="CUDA编程模型"></a>CUDA编程模型</h3><p>程序中用host指代CPU及其内存, 用device指代GPU及其内存.CUDA程序中既包含host程序又包含device程序,他们分别在CPU和GPU上运行. 同时,host与device之间可以进行通信.</p>
<ol>
<li>nvcc的编译过程</li>
</ol>
<p><img src="/Pictures/nvcc编译过程.png" alt="nvcc编译过程"></p>
<p>CUDA的编译器驱动nvcc先将全部源代码分离为主机(host)代码和设备(device)代码。主机代码完全支持C++语法，而设备代码只是部分支持。</p>
<p>nvcc先将设备代码编译为PTX(Parallel Thread eXecution)伪汇编代码，再将PTX代码编译为二进制的cubin目标代码</p>
<ol start="2">
<li>nvcc编译选项</li>
</ol>
<ul>
<li><p>在将源代码编译为PTX代码时，需要用选项<code>-arch=copute_XY</code>指定一个虚拟架构的计算能力，以确定代码中能够使用的CUDA功能。</p>
</li>
<li><p>在将PTX代码编译为cubin代码时，需要用选项<code>-code=sm_ZW</code>指定一个真实架构的计算能力，以确定可执行文件能使用的GPU。指定了GPU的真实架构为Z.W,对应的可执行文件只能在主版本号为Z、次版本号大于等于W的GPU中运行。</p>
</li>
<li><p>真实架构的计算能力必须大于虚拟架构的计算能力</p>
</li>
<li><p>使得编译出来的可执行文件在更多的GPU中执行，可以同时指定多组计算能力，每一组用如下形式的编译选项：<br><code>gencode arch=compute_XY,code=sm_ZW</code></p>
</li>
<li><p>即时编译：在运行可执行文件时，从其中保留的PTX代码中临时编译出一个cubin目标代码，编译时保留这样的PTX代码需要用如下编译选项指定虚拟架构：<br><code>-gencode arch=compute_XY,code=compute_XY</code></p>
</li>
<li><p><code>arch=sm_XY</code>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-gencode arch=compute_XY,code=sm_XY</span><br><span class="line">-gencode arch=compute_XY,code=compute_XY</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>CUDA程序的基本框架</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">头文件包含</span><br><span class="line">宏定义</span><br><span class="line">用户函数和CUDA核函数的声明</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    分配主机与设备内存</span><br><span class="line">    初始化主机中的数据</span><br><span class="line">    将某些数据从主机复制到设备</span><br><span class="line">    调用核函数在设备中进行计算</span><br><span class="line">    将某些数据从设备复制到机</span><br><span class="line">    释放主机与设备内存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CUDA-C语法"><a href="#CUDA-C语法" class="headerlink" title="CUDA C语法"></a>CUDA C语法</h3><p><img src="/Pictures/线程分配.png" alt="线程分配"></p>
<ul>
<li>核函数中的线程常组织为若干个线程块(thread block)，每个线程块中有若干个线程(thread)。</li>
<li>核函数中的全部线程块构成一个网格(grid)，线程块的个数记为网格大小(grid size)，每个线程块中有同样数目的线程，该数目称为线程块大小(block size)。</li>
</ul>
<ol>
<li>__global__</li>
</ol>
<p><strong>global</strong>是CUDA C/C++的函数修饰符, 表示该函数为一个kernel函数, 该函数在CPU上调用，且:</p>
<ul>
<li>该函数会在GPU(device)上执行</li>
<li>必须返回void</li>
<li>由主机(host)代码调用:<br><code>fun_name&lt;&lt;&lt;grid_size, block_size&gt;&gt;&gt;()</code></li>
<li>在调用kernel函数时,函数名后的&lt;&lt;&lt;grid_size, block_size&gt;&gt;&gt;<ul>
<li>gird_size表示网格大小</li>
<li>block_size表示线程块大小</li>
</ul>
</li>
</ul>
<ol start="2">
<li>线程索引<br>在核函数内部，程序将配置参数gird_size和block_size这两个参数值分别保存于如下两个内建变量(built-in variable)中：</li>
</ol>
<ul>
<li>gridDim.x: 数值于grid_size相等</li>
<li>blockDim.x: 数值与block_size相等<br>类似地，在核函数中预定义了如下表示线程的内建变量：</li>
<li>blockIdx.x: 指定一个线程在网格中的线程块指标，取值范围是从0到gridDim.x-1。</li>
<li>threadIdx.x: 指定一个线程在线程块中的线程指标，取值范围是从0到blockDim.x-1。</li>
</ul>
<ol start="3">
<li>多维网格</li>
</ol>
<ul>
<li>unit3：<br>  blockIdx和threadIdx是类型为unit3的结构体变量，该结构体共有三个成员变量x，y，z。</li>
<li>gridDim：<br>  gridDim和blockDim是类型为dim3的结构体变量，该结构体共有三个成员变量x，y，z。<br>这些内建变量均只在核函数中有效(可见)。在调用核函数时的执行配置中：  </li>
</ul>
<p><code>&lt;&lt;&lt;grid_size, block_size&gt;&gt;&gt;</code>  </p>
<p>grid_size和block_size的值被分别赋给内建变量gridDim.x和blockDim.x，此时，girdDim和blockDim中没有被指定的成员y和z取默认值1。在这种情况下，网格和线程块均为“一维”的。</p>
<ul>
<li>构造多维网格和线程块：<br>因为gird_size和block_size均为dim3结构体类型，所以可以通过结构体dim3来定义多维的网格和线程块(用到了C++中构造函数的语法)：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">grid_size</span><span class="params">(Gx ,Gy, Gz)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">block_size</span><span class="params">(Bx, By, Bz)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>表示一维时，y和z可省略<br>表示二维时，z可省略</p>
<p>多维线程块本质上还是一维的，与多维线程指标threadId.x, threadIdy, threadId.z对应的一维线程指标为：  </p>
<p><code>tid = threadId.x * blockDim.x + threadId.y * blockDim.y + threadId.z * blickDim.z;</code></p>
<p>与多维线程块指标blockIdx.x, blockIdx.y, blockIdx.z相关联的线程块指标为：</p>
<p><code>bid = blockIdx.z * girdDim.x * gridDim.y + blockIdx.y * gridDim.x + blockIdx.x;</code></p>
<ul>
<li>网格与线程块大小的限制</li>
</ul>
<p>网格大小(grid_size)在x、y、z三个方向的最大允许值分别为2^31-1、65535、65535</p>
<p>线程块大小(thread_size)在x、y、z三个方向的最大允许值分别为1024、1024、64。且blockDim.x、 blockDim.y、blockDim.z的乘积不能大于1024，即无论如何分配，一个线程块最多只能有1024个线程。</p>
<ul>
<li>通常，一个网格会被组织成线程块的二维形式，一个线程块会被组织成线程的三维形式。</li>
</ul>
<ol start="4">
<li>函数执行空间标识符</li>
</ol>
<ul>
<li>用<strong>global</strong>修饰的函数叫做核函数，一般由主机调用，在设备执行。如果使用动态并行，则也可以在核函数中调用自己或其它核函数</li>
<li>用<strong>device</strong>修饰的函数叫做设备函数，只能被核函数或其它设备函数调用，并在设备中执行。</li>
<li>用<strong>host</strong>修饰的函数就是普通的C函数，在主机调用和执行。可以用<strong>host</strong>和<strong>device</strong>同时修饰一个函数，使得该函数既是一个主机函数，又是一个设备函数，以减少冗余代码。</li>
<li>不能同时用<strong>device</strong>和<strong>global</strong>修饰一个函数，即一个函数不能同时为设备函数和核函数</li>
<li>不能同时用<strong>host</strong>和<strong>global</strong>修饰一个函数，即一个函数不能同时为主机函数和核函数。</li>
<li>编译器把设备函数当做内联函数或非内联函数，可用修饰符<strong>noinline</strong>建议一个设备函数为非内联函数，也可以用修饰符<strong>forceinline</strong>建议一个设备函数为内联函数。</li>
</ul>
<ol start="5">
<li>设备内存的分类</li>
</ol>
<p><img src="/Pictures/内存类型.png" alt="设备内存分类"></p>
<p><strong>全局内存</strong></p>
<p>全局内存的含义是核函数中的所有线程都能够访问其中的数据。主要作用是为核函数提供数据，并在主机与设备以及设备与设备之间传输数据。<br>全局内存的生命周期不是由核函数决定的，而是由主机端决定的</p>
<p><strong>静态全局内存变量</strong></p>
<p>静态全局内存变量所占的内存数量是在编译期间就确定的，且必须在说有主机与设备函数外部定义。<br>对应的变量从其定义之处开始、一个翻译单元内的所有设备函数直接可见。</p>
<p>静态全局内存变量的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__device__ T x = <span class="number">0</span>; <span class="comment">//单个变量</span></span><br><span class="line">__device__ T y[N];  <span class="comment">//固定长度的数组</span></span><br></pre></td></tr></table></figure></p>
<p>T为变量类型。   </p>
<p>一般来说不建议使用静态全局内存变量</p>
<p><strong>常量内存</strong></p>
<p>常量内存是具有缓存的全局内存，一共仅有64KB，仅可读不可写。</p>
<p>在核函数外用<strong>constant</strong>定义常量内存，并用CUDA运行时API函数cudaMemcpyToSymbol将数据从主机端复制到设备的常量内存后供核函数使用。核函数对常量内存的访问要比对全局内存的访问要快。</p>
<p>计算能力大于等于2.0时，通过传值方式传给核函数的参数存放在常量内存中，该参数的内存在大于4KB，小于64KB时必须在定义时用<strong>constant</strong>修饰</p>
<p><strong>纹理内存和表面内存</strong></p>
<p>纹理内存和表面内存类似于常量内存，也是一种具有缓存的全局内存，而且一般仅可读(表面内存也可写)。但是纹理内存和表面内存的容量更大，且使用方式与常量内存不同。</p>
<p>对于算力大于等于3.5的GPU而言，将某些只读全局内存变量用<strong>__ldg()</strong>函数通过只读数据缓存读取，可以达到到使用纹理内存的加速效果。</p>
<p><code>T __ldg(const T *address)</code></p>
<p><strong>寄存器</strong></p>
<p>核函数中定义的不加任何限定符的变量一般来说存放在寄存器(register)中，但也可能存放于局部内存。</p>
<p>各种内建变量以及线程束大小(warpSize)都保存在特殊的寄存器中</p>
<p>寄存器变量仅仅被一个线程可见。</p>
<p><strong>局部内存</strong></p>
<p>寄存器中放不下的变量，以及索引值不能在编译时就确定的数组，有可能放在局部内存，由编译器自动决定。</p>
<p><strong>共享内存</strong></p>
<p>共享内存存在于芯片上，具有仅次于寄存器的读写速度。但它对于整个线程块可见，生命周期也与整个线程块一致。</p>
<p>共享内存的作用是减少对全局内存的访问。</p>
<ol start="6">
<li>检测运行时错误</li>
</ol>
<ul>
<li>CHECK函数<br>在头文件文件error.cuh中编写宏函数CHECK，输出捕获的运行时错误。<br>函数头为：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK(call) \</span></span><br><span class="line">...                 \</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中call为一个CUDA运行时API函数，调用时将一个CUDA运行时API函数作为参数传进该函数即可检验此运行时API函数在运行时发生的错误，并输出错误信息。</p>
<ul>
<li>检查核函数<br>捕捉调用核函数时可能发生的错误，需要在调用核函数之后加上如下两句：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CHECK(cudaGetLastError());</span><br><span class="line">CHECK(cudaDeviceSynchronize());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="7">
<li><p>CUDA-MEMCHECK检查内存错误<br>CUDA-MEMCHECK工具集包括memcheck、rececheck、initcheck、synccheck四个工具。他们可由可执行文件cuda-memcheck调用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cuda-memcheck --tool memcheck [options] app_name [options]</span><br><span class="line">cuda-memcheck --tool racecheck [options] app_name [options]</span><br><span class="line">cuda-memcheck --tool initcheck [options] app_name [options]</span><br><span class="line">cuda-memcheck --tool synccheck [options] app_name [options]</span><br></pre></td></tr></table></figure>
</li>
<li><p>用CUDA事件计时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cudaEvent_t start, stop;</span><br><span class="line">cudaEventCreate(&amp;start); <span class="comment">//创建事件类型变量</span></span><br><span class="line">cudaEventCreate(&amp;stop);</span><br><span class="line">cudaEventRecord(start); <span class="comment">//记录事件的开始</span></span><br><span class="line">cudaEventQuery(start);  <span class="comment">//查询Record是否完成事件的捕获</span></span><br><span class="line"></span><br><span class="line">operate_fun(...);</span><br><span class="line"></span><br><span class="line">cudaEventRecord(stop);  <span class="comment">//记录事件的结束</span></span><br><span class="line">cudaEventSynchronize(stop); <span class="comment">//等待记录完成</span></span><br><span class="line"><span class="keyword">float</span> elapsed_time;</span><br><span class="line">cudaEventElapsedTime(&amp;elapsed_time, start, stop);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Time = %f ms.\n"</span>, elapsed_time);</span><br><span class="line">cudaEventDestory(start);</span><br><span class="line">cudaEventDestory(stop);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>创建事件 -&gt; 记录事件的开始 -&gt; 计时部分代码执行 -&gt; 记录事件的结束 -&gt; 计算耗时</p>
<p><strong>GPU计算核心</strong>和<strong>设备内存</strong>之间的数据传输的传输峰值理论带宽要远大于<strong>CPU</strong>与<strong>GPU</strong>之间数据传输的理论峰值带宽，所以，想要获得可观的加速，就必须减少在数据传输上所花的时间，避免过多的数据经过PCIe传递。</p>
<ol start="9">
<li>算数强度</li>
</ol>
<p>一个计算问题的算数强度指的是其中<strong>算数操作</strong>的工作量与<strong>必要的内存操作</strong>的工作量之比</p>
<ol start="10">
<li>一个CUDA程序获得高性能的必要条件：</li>
</ol>
<ul>
<li>数据传输比重小</li>
<li>核函数的算数强度较高</li>
<li>核函数中定义的线程数目较多</li>
</ul>
<p>所以，在优化CUDA程序时尽量做到：</p>
<ul>
<li>减少主机与设备之间的数据传输</li>
<li>提高核函数的算数强度</li>
<li>增大核函数的并行规模</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol>
<li>cudaDeviceRest()</li>
</ol>
<p>用来显式地释放和清空当前进程中与当前设备有关的所有资源。</p>
<ol start="2">
<li>cudaMalloc</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMalloc</span><span class="params">(<span class="keyword">void</span>** devPtr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>同C语言中malloc函数，为变量分配空间。第一个参数为内存分配的对象，第二个是分配的内存空间的<strong>字节</strong>大小。</p>
<ol start="3">
<li>cudaMemcpy</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMemcpy</span><span class="params">(<span class="keyword">void</span>* dst, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">size_t</span> count, cudaMemcpuKind kind)</span></span>;</span><br></pre></td></tr></table></figure>
<p>从src指向的内存空间复制一定字节的数据到dst所指内存中，复制方向由kind指定，kind共有以下几种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cudaMemcpyHostToHost</span><br><span class="line">cudaMemcpyHostToDevice</span><br><span class="line">cudaMemcpyDeviceToHost</span><br><span class="line">cudaMemcpyDeviceToDevice</span><br></pre></td></tr></table></figure></p>
<p>该函数以同步方式执行，在函数返回以及传输操作完成之前主机的应用程序是阻塞的。</p>
<ol start="4">
<li>cudaGetErrorString</li>
</ol>
<p>cudaError_t为枚举类型，此类型变量有两个值：  <strong>cudaSuccess</strong>与<strong>cudaErrorMemoryAllocaion</strong>  </p>
<p>将错误代码转为可读字符串</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">cudaGetErrorString</span><span class="params">(cudaError_t error)</span></span>;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>cudaEventElapsedTime</li>
</ol>
<p>计算事件之间经过(Elapse)的时间<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function">host__ cudaError_t <span class="title">cudaEventElapsedTime</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">float</span>* ms,        <span class="comment">//返回事件执行的时间</span></span></span></span><br><span class="line"><span class="function"><span class="params">    cudaEvent_t start, <span class="comment">//事件的开始</span></span></span></span><br><span class="line"><span class="function"><span class="params">    cudaEvent_t end    <span class="comment">//事件的结束</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        
<div class="counter-tag counter">
    <span id="/2020/03/15/CUDA/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="CUDA学习记录">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-MPI" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/29/MPI/" class="article-date">
  	<time datetime="2020-02-29T08:03:47.000Z" itemprop="datePublished">2020-02-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/29/MPI/">
        MPI学习记录
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MPI-Learning-Record"><a href="#MPI-Learning-Record" class="headerlink" title="MPI_Learning_Record"></a>MPI_Learning_Record</h2><p>环境下载:<br><a href="http://www.mpich.org/downloads/" target="_blank" rel="noopener">http://www.mpich.org/downloads/</a></p>
<ol>
<li>程序的开始与结束</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Init</span><span class="params">(<span class="keyword">int</span> *argc, <span class="keyword">char</span> **argv)</span></span></span><br></pre></td></tr></table></figure>
<p>通过MPI_Init函数进入MPI环境并完成初始化工作，标志并行代码的开始, 前后两个参数为main函数的默认参数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Finalize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>通过MPI_Finalize函数从MPI环境中推出，标志并行代码的结束，如果不是MPI程序的最后一句则运行结果不可知</p>
<ol start="2">
<li>获取进程的数量：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_size</span><span class="params">(MPI_Comm comm, <span class="keyword">int</span> *rank)</span></span></span><br></pre></td></tr></table></figure>
<p>通信子：一组可以相互发送消息的进程集合。通常由MPI_Init()在用户启动程序时， 定义由用户自动的所有进程组成的通信子， 缺省值为MPI_COMM_WORLD。这个参数是MPI通信操作函数中必不可少的参数，用户限定参加通信的进程的范围。</p>
<p>参数: 第一个参数是通信子， 第二个参数返回进程的个数</p>
<ol start="3">
<li>获取进程id</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_rank</span><span class="params">(MPI_Comm comm, <span class="keyword">int</span> *rank)</span></span></span><br></pre></td></tr></table></figure>
<p>获得当前进程在制定通信域中的编号，将自身与其他程序区分。  </p>
<p>第一个参数是通信子，第二个参数返回进程的编号。</p>
<ol start="4">
<li>获取处理器</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Get_processor_name</span><span class="params">(<span class="keyword">char</span> *name, <span class="keyword">int</span> *resultlen)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *name</span>;  #返回处理器名</span><br><span class="line"><span class="keyword">int</span> *resultlen;  #在name中返回结果的长度</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><p>运行时间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">MPI_Wtime</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//获取时间</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">MPI_Wtick</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//查看时间的精度</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同步</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Barrier</span><span class="params">(MPI_Comm comm)</span></span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 时间精度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">MPI_Wtick</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//查看时间的精度</span></span></span><br></pre></td></tr></table></figure>
<ol start="8">
<li>消息传递</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Send</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* msg_buf_p,<span class="comment">//变量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> msg_size, <span class="comment">//数据量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype send_type, <span class="comment">//发送信息的数据类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> dest, <span class="comment">//目标进程的id值</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> tag, <span class="comment">//消息标签，0打印，1计算</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm communicator<span class="comment">//通信子</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Recv</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* msg_buf_p, <span class="comment">//变量指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> buf_size, <span class="comment">//数据量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype recv_type, <span class="comment">//发送信息的数据类型；</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> source, <span class="comment">//接收的进程的id值；</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> tag, <span class="comment">//消息标签；0打印，1计算</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm communicator， <span class="comment">//通信子；</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Status *status_p)</span><span class="comment">//status_p对象，包含实际接收到的消息的有关信息</span></span></span><br></pre></td></tr></table></figure>
<p>通常情况下，满足以下条件，就可以成功发送和接收消息：</p>
<pre><code>1. recv_type = send_type
2. recv_buf_size &gt;= send_buf_size
</code></pre><p>接收者的通配参数：</p>
<ul>
<li>MPI_ANY_SOURSE: 当第四个参数source为此变量时，代表任何一个完成工作的进程</li>
<li>MPI_ANY_TAG: 当第五个参数tag为此变量时，代表接收任意形式的标签</li>
</ul>
<p>通配参数只有<code>接收者</code>可以使用</p>
<ol>
<li>地址偏移量</li>
</ol>
<p>MPI_ADDRESS: 获得一个位置在内存中的地址<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Address</span><span class="params">(<span class="keyword">void</span> *location, MPI_Aint *address)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line">void *location: 调用者的内存位置；</span><br><span class="line">MPI_Aint *address: 位置的对应地址</span><br></pre></td></tr></table></figure></p>
<ol start="10">
<li>(规约)集合通信函数</li>
</ol>
<p>涉及通信子中的所有进程的通信函数称为集合通信。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Reduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* input_data_p,     <span class="comment">//每个线程需要提供的计算数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* output_data_p,    <span class="comment">//返回计算结果</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> count,              <span class="comment">//每个线程提供的数据量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype datatype,  <span class="comment">//数据类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_OP <span class="keyword">operator</span>,        <span class="comment">//归约操作符</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> dest_process,       <span class="comment">//在指定线程中返回</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm comm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在指定线程中对通信子中每个线程中的数据进行特定的计算(MPI_OP)，并在该线程中返回计算结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Allreduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* input_data_p,     <span class="comment">//每个线程需要提供的计算数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* output_data_p,    <span class="comment">//返回计算结果</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> count,              <span class="comment">//每个线程提供的数据量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype datatype,  <span class="comment">//数据类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_OP <span class="keyword">operator</span>,        <span class="comment">//归约操作符</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm comm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>与上面类似，除去dest_process参数。在通信子的所有线程中均返回结果。<br>具体实现：在一个线程中计算出结果后，将结果发布给其他线程。</p>
<p>MPI_OP:</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符值</th>
<th style="text-align:left">含义</th>
<th style="text-align:center">\</th>
<th style="text-align:left"></th>
<th style="text-align:left">运算符值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">MPI_MAX</td>
<td style="text-align:left">求最大值</td>
<td style="text-align:center">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">MPI_LOR</td>
<td>逻辑或</td>
</tr>
<tr>
<td style="text-align:left">MPI_MIN</td>
<td style="text-align:left">求最小值</td>
<td style="text-align:center">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">MPI_BOR</td>
<td>按位或</td>
</tr>
<tr>
<td style="text-align:left">MPI_SUM</td>
<td style="text-align:left">求累加和</td>
<td style="text-align:center">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">MPI_LXOR</td>
<td>逻辑异或</td>
</tr>
<tr>
<td style="text-align:left">MPI_PROD</td>
<td style="text-align:left">求累乘积</td>
<td style="text-align:center">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">MPI_BXOR</td>
<td>按位异或</td>
</tr>
<tr>
<td style="text-align:left">MPI_LAND</td>
<td style="text-align:left">逻辑与</td>
<td style="text-align:center">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">MPI_MAXLOC</td>
<td>求最大值和最大值所在位置</td>
</tr>
<tr>
<td style="text-align:left">MPI_BAND</td>
<td style="text-align:left">按位与</td>
<td style="text-align:center">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">MPI_MINLOC</td>
<td>求最小值和最小值所在位置</td>
</tr>
</tbody>
</table>
<ol start="11">
<li>广播<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Bcast</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* data_p,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype datatype,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> source_proc,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm comm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>进程号为cource_proc的进程将data_p所引用的内存内容发送给通信子comm中的所有进程</p>
<ol start="12">
<li>散射</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>*           send_buf_p, <span class="comment">//需要处理的整体数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>             send_count, <span class="comment">//发送到每个进程的数据量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype    send_type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>*           recv_buf_p, <span class="comment">//本地定义的数组或其他容器用来存储分得的数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>             recv_count, <span class="comment">//每个进程分得的数据量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype    recv_type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>             src_proc,   <span class="comment">//负责读取和分发数据的进程</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm        comm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>若通信子comm包含comm_sz个进程，那么MPI_Scatter函数会将send_buf_p所引用的数据分成comm_sz份，第一份分给0号进程，第二分分给1号进程……以此类推。</p>
<ol start="13">
<li>聚集</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Gather</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>*           send_buf_p,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>             send_count,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype    send_type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>*           recv_buf_p,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>             recv_count,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype    recv_type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>             dest_proc,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm        comm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在指定线程dest_proc中收集当前线程传来的数据，保存在大小为recv_count的recv_type类型数组recv_count中</p>
<ol start="14">
<li>派生数据类型 ???</li>
</ol>
<p>一个派生数据类型是由一系列的MPI基本数据类型和每个数据类型的偏移所组成的</p>
<p>假设一个进程里变量a,b,n和它们在内存中的位置如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">24</td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:center">40</td>
</tr>
<tr>
<td style="text-align:center">n</td>
<td style="text-align:center">48</td>
</tr>
</tbody>
</table>
<p>则可以用以下的派生数据类型表示这些数据项：</p>
<p>{(MPI_DOUBLE,0),(MPI_DOUBLE,16),(MPI_INT,24)}</p>
<p>每组数据的第二个元素是该数据项相对于起始位置的偏移, 即为当前数据与起始数据的内存地址差值。</p>
<p>可以用MPI_Type_creaate_struct函数创建有不同基本数据类型的元素组成的派生数据类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Type_create_struct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> count, <span class="comment">//数据类型中元素的个数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> array_of_blocklengths[]， <span class="comment">//允许单独的数据项可以是个数组,每个元素表示数组长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Aint array_of_displacements[]，<span class="comment">//距离消息起始位置的偏移量,单位为字节</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype array_of_types[],<span class="comment">//数据类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype* new_type_p  <span class="comment">//函数建立的新的数据类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以使用MPI_Get_address函数来找到制定元素的内存地址<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Get_address</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    voiod* location_p,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Aint* adddress_p</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>MPI_Aint是个长整数型, address_p返回location_p所指向的内存单元的地址</p>
<p>生成新的数据类型之后需要调用函数MPI_Type_commit去指定它:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Type_commit</span><span class="params">(MPI_Datatype* new_mpi_t_p)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>调用派生数据类型: 以MPI_Bcast测试:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MPI_Bcast(&amp;a, <span class="number">1</span>, <span class="keyword">input_mpi_t</span>, <span class="number">0</span>, comm);</span><br></pre></td></tr></table></figure></p>
<ol start="15">
<li>数据的打包(Pack)</li>
</ol>
<p>将不连续的数据或是不相同的数据类型的数据一起发送到其它进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Pack</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* inbuf,  <span class="comment">//待打包的数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> incount,  <span class="comment">//打包的数据量</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype datatype, <span class="comment">//数据项的类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *outbuf,  <span class="comment">//输入冲区地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> outcount,  <span class="comment">//输入缓冲区大小</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *position, <span class="comment">//缓冲区第一个用于打包的位置</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm, comm <span class="comment">//通信子</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Unpack</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* inbuf,             <span class="comment">// 指向待解包缓冲区的指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> insize,              <span class="comment">// 缓冲区大小（单位为 Byte）</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>* position,           <span class="comment">// 输出缓冲区中第一个用于打包的位置（地址偏移量）</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* outbuf,            <span class="comment">// 指向解包后数据的指针 </span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> outcount,            <span class="comment">// 解包元素个数    </span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype datatype,   <span class="comment">// 数据类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm comm            <span class="comment">// 通信子</span></span></span></span><br><span class="line"><span class="function"><span class="params"> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>缓冲区的类型任意, 意在分配指定大小的空间足够打包解包时使用, position大小随打包和解包增加和减少</p>
<p>打包完成后可以通过MPI_Send等发送数据的函数将输入缓冲区<strong>outbuf</strong>发送到其他线程,类型为<strong>MPI_PACKED</strong></p>
<p>接收函数MPI_Recv等接收到其他线程发来的包后,需要对其进行解包操作,提取出相应的数据后才能进行下一步操作</p>
<ol start="16">
<li>组的管理</li>
</ol>
<p>组是一个进程的有序集合,在实现中可以看做是进程标识符的一个有序集合,组内的每个进程与一个整数rank相联系,序列号从0开始并且是连续的.我们可以在通信组中使用组来描述通信空间中的参与者并对这些参与者进行分级.</p>
<p>两个特殊的预定义组:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MPI_GROUP_EMPTY: 空组的有效句柄,可以再组操作中作为一个参数使用</span><br><span class="line">MPI_GROUP_NULL: 无效句柄,在组释放时会被返回</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>创建</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_group</span><span class="params">(MPI_Comm comm, MPI_Group *group)</span></span>; </span><br><span class="line"><span class="comment">/*建立一个通信组对应的新进程组. group返回组句柄*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Group_rank</span><span class="params">(MPI_Group group, <span class="keyword">int</span> *rank)</span></span>; </span><br><span class="line"><span class="comment">/*查询调用进程在进程组里的rank*/</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>说明: MPI不能凭空构造一个组,只能从其他以前定义的组中构造,最基本的组是与初始通信子MPI_COMM_WORLD相联系的组(可通过MPI_COMM_GROUP获得),其他的组均在该组基础上定义.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Group_incl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group old_group,  <span class="comment">//旧进程组</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> count,            <span class="comment">//members数组中元素的个数 </span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *members,         <span class="comment">//旧进程组中需要放入新进程组进程的编号</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group *new_group  <span class="comment">//新进程组</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>基于已经存在的进程组创建一个新的进程组,并指明被包含(include)的成员进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Group_excl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group old_group, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *nonmembers,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group *new_group</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>基于已经存在的进程创建一个新的进程组,并指明不被包含(exclude)的成员进程, 即新进程组包含除nonmembers之外的其它进程</p>
<ul>
<li><strong>比较</strong></li>
</ul>
<p>对两个进程组判断其成员是否相同,次序是否一致.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Group_compare</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group1, </span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *result</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure>
<p>如果两个组中成员和次序完全相等,则返回<strong>MPI_IDENT</strong><br>如果组成员相同但次序不同,则返回<strong>MPI_SIMILAR</strong><br>其它情况返回<strong>MPI_UNEQUAL</strong></p>
<ul>
<li><strong>相对编号</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Group_translate_ranks</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group1, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> count,   <span class="comment">//进程组1中有效编号的个数</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *ranks1, <span class="comment">//进程组1中有效编号组成的数组</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group2,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> *ranks2  <span class="comment">//ranks1中的元素在进程组2中的对应编号</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>检测两个不同组中相同进程的相对编号,如果属于进程组1的某个进程的编号在ranks1中,但此进程不属于进程组2,则在ranks2中对应ranks1的位置返回值为MPI_UNDEFINED;若此进程属于进程组2,则在ranks2中对应ranks1的位置返回此进程在进程组2中的编号</p>
<ul>
<li><p><strong>集合类操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Group_union</span><span class="params">( <span class="comment">//进程组的集合并操作</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group1,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group2,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group *newgroup</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Group_intersection</span><span class="params">( <span class="comment">//进程组的集合交操作</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group1, </span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group2,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group *newgroup</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Group_defference</span><span class="params">(  <span class="comment">//newgroup=group2-group1</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">/*进程组的集合补操作, 返回group1在group2中的相对补集*/</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group1,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group2,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group *newgroup</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>释放</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int MPI_Group_free(MPI_Group *group);</span><br></pre></td></tr></table></figure>
<p>释放指定进程组,组句柄被置为MPI_GROUP_NULL  </p>
<p>函数允许任何正在使用此组的操作正常完成</p>
<ol start="17">
<li>通信子的管理</li>
</ol>
<ul>
<li><p><strong>复制</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_dup</span><span class="params">(MPI_Comm comm, MPI_Comm *newcomm)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>创建</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_creeate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm comm,   <span class="comment">//旧通信子</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Group group, <span class="comment">//与comm相关联的组或其子集</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm *new_comm <span class="comment">//新通信子</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用由group所定义的通信组及一个新的上下文创建了一个新的通信自new_comm,对于不在group中的进程,函数返回MPI_COMM_NULL,所以新的通信子中包含group中的进程</p>
<ul>
<li><strong>划分</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_split</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm comm, <span class="comment">//旧的通信子,即被划分的域</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> color,  <span class="comment">//子域的标识,被划分出来的每个子域都对应一个color,每个子域包含具有同样color的所有进程</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> key, <span class="comment">//每个子域内,进程按照key所定义的值的次序进行排列</span></span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Comm *new_comm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>函数将与comm相关的域划分为若干不相连的子域,根据color和key参数决定每个进程所处的位置</p>
<ul>
<li><strong>释放</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Comm_free</span><span class="params">(MPI_Comm *comm)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将指定通信子的句柄置为MPI_COMM_NULL,任何使用此通信子的挂起操作都会正常完成;仅当没有对此对象的活动引用时,它才会被实际撤销</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        
<div class="counter-tag counter">
    <span id="/2020/02/29/MPI/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="MPI学习记录">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-OpenMP" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/02/10/OpenMP/" class="article-date">
  	<time datetime="2020-02-10T08:02:39.000Z" itemprop="datePublished">2020-02-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/10/OpenMP/">
        OpenMP学习记录
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="OpenMP-Learning-Record"><a href="#OpenMP-Learning-Record" class="headerlink" title="OpenMP Learning Record"></a>OpenMP Learning Record</h2><p>在C/C++中, OpenMP可以通过使用预处理指令来让程序并行化, OpenMP指令使用的格式为:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp 指令</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>time.clock()与omp_get_wtime()</li>
</ol>
<p>clock()函数返回从“开启这个程序进程”到“程序中调用clock()函数”时之间的CPU时钟计时单元(clock<br>tick)数, 在omp程序中多个线程同时运行, 用clock计时并不能得到想要的结果.</p>
<p>omp_get_wtime()函数返回从某一时间点到调用时所经过的时间</p>
<ol start="2">
<li>for指令</li>
</ol>
<p>for指令的作用是使一个for循环在多个线程中执行, 一般for指令与parallel指令同时使用, 即parallel for. 此外还可以在parallel指令的并行块中单独使用, 在一个并行快中可以使用多个for指令. 但是单独使用for指令是没有效果的.</p>
<ol start="3">
<li>parellel指令</li>
</ol>
<p>parallel是构造并行块的指令, 同时也可以配合其它指令如for, sections等一起使用. 在这个指令后需要使用一对大括号来制定并行代码块.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel [for | sections] [子句[子句]...]</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//并行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="4">
<li>num_threads(thread_num)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel num_threads(thread_num)</span></span><br></pre></td></tr></table></figure>
<p>指定执行此代码块的线程数量</p>
<ol start="5">
<li>omp_get_num_procs()</li>
</ol>
<p>返回调用函数时, 可用的线程数目</p>
<ol start="6">
<li>omp_get_num_threads()</li>
</ol>
<p>返回当前并行区域中的活动线程个数, 若在并行区域之外调用则返回0</p>
<ol start="7">
<li>omp_get_max_threads()</li>
</ol>
<p>返回最大的线程数量, 这里的最大线程数量是指在不使用num_threads的情况下OpenMP可以创建的最大线程数量</p>
<ol start="8">
<li>sections和section</li>
</ol>
<p>sections语句指定一个并行代码块, 并用section语句将此代码块分为多个分块, 各个分块并行执行<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel sections</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//section1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//section2</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="9">
<li>omp_in_parallel</li>
</ol>
<p>判断当前是否处于并行状态, 返回1表示是, 返回0表示否. </p>
<ol start="10">
<li>private子句</li>
</ol>
<ul>
<li>private<br>将变量声明为线程私有, 声明私有之后,每个线程都获得一个该变量的副本, 线程之间不会相互影响, 各自之间不能相互访问对方的私有变量, 且原变量在并行部分不起任何作用, 值也不会因为并行代码块中的操作而改变</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel [for|section] private(value)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>firstprivate</li>
</ul>
<p>功能与private类似, firstprivate可继承变量原来的值, 但不保留操作后的值</p>
<ul>
<li>lastprivate</li>
</ul>
<p>将变量操作后的值保存下来带出并行代码块, 需要注意的是, 根据OpenMP规范:  </p>
<ol>
<li>在循环迭代中, 是最后一次迭代的值赋给原变量</li>
<li>在section结构中 ,是程序语法上的最后一个section语句的结果赋原变量</li>
<li>如果是类(class)变量作为lastprivate的参数时, 我们需要一个缺省构造函数, 除非该变量也作为子句的参数;此外还需要拷贝一个赋值操作符</li>
</ol>
<ul>
<li>threadprivate</li>
</ul>
<p>将一个变量分别复制一份拷贝给各个线程, 作为各个线程的私有变量, 即各个线程具有各自私有的全局对象, 而不止在并行代码块中有效.<br>此变量只能为全局变量或静态变量(static), 且threadprivate语句要紧跟在变量声明的后边</p>
<ol start="11">
<li>shared</li>
</ol>
<p>将一个变量声明为共享变量, 并在多个线程内共享. 程序分配一块单独的内存给这个变量, 所有的并行线程共享这块内存空间. 在并行部分进行写操作时, 要求对共享变量进行保护, 否则不要随便使用共享变量, 尽量将共享变量换为私有变量使用.</p>
<ol start="12">
<li>reduction</li>
</ol>
<p>对一个或多个参数指定一个操作符, 然后每一个线程都会创建这个参数的私有拷贝, 在各自的线程中对其进行操作, 在并行区域结束后, 迭代指定的运算符, 并更新原参数值.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reduction(<span class="keyword">operator</span>: <span class="built_in">list</span>);</span><br><span class="line"><span class="comment">//operator为操作符, list为一个变量或多个变量组成的数组*/</span></span><br></pre></td></tr></table></figure></p>
<ol start="13">
<li>copyin</li>
</ol>
<p>将主线程中的变量值拷贝到各个线程的私有变量中, 但是主线程中的变量值不会改变.<br>只有被声明为threadprivate的变量才可作为copyin子句的参数</p>
<ol start="14">
<li>循环调度: schedule</li>
</ol>
<p>schedule只能用于循环并行构造中, 作用是控制循环并行结构的任务调度, 将循环迭代分配给各个线程.<br>语法为:<code>schedule(kind, chunk_size)</code></p>
<ul>
<li>静态调度static</li>
</ul>
<p>schedule(static, size): size为每个线程分配的迭代数, 若不给出size参数, 则程序将迭代数/总线程数作为size的值</p>
<p>“静态”体现在这个调度过程跟程序的实际运行无关, 可以指定或推理出那几次迭代在哪几个线程中运行<br>在用户没有使用schedule子句的并行循环中, 系统默认采用static方式进行调度. </p>
<ul>
<li>动态调度dynamic</li>
</ul>
<p>schedule(dynamic, size): 动态调度依赖程序运行状态, 无法预知哪次迭代在哪个线程中运行. </p>
<p>在没有指定size的情况下, 各个线程按照执行完即分配的方式进行调度, 只要还有迭代没有完成, 哪个线程开始空闲就将下一次迭代分配给它, 直到完成循环迭代</p>
<p>指定的size参数表示每次分配给线程的迭代次数, 默认size为1</p>
<ul>
<li>guided调度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">schedule(guided, size)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>类似与动态调度, 但是每次分配的迭代次数不同. 设每次分配的迭代次数为n, 则n会随着每次分配逐渐减小, size表示n的最小值, 即当n减小到size时将不在减小, 无论是否已经分配完. 默认size为1</p>
<ul>
<li>runtime</li>
</ul>
<p>runtime表示根据环境变量确定上述调度策略中的某一种, 默认也是静态的(static). </p>
<p>控制schedule环境变量的是OMP_SCHEDULE环境变量, 值为上面三种类型的一种, 例如:<br>OMP_SCHEDULE=”dynamic, 5”<br>表示schedule(dynamic, 5)</p>
<ol start="15">
<li>互斥锁</li>
</ol>
<ul>
<li><p>初始化互斥锁:<br><code>void omp_init_lock(omp_lock_t lock);</code><br>在使用锁之前要将其初始化</p>
</li>
<li><p>销毁互斥锁:<br><code>void omp_destroy_lock(omp_lock_t* lock);</code><br>不再使用锁时, 要将其销毁</p>
</li>
<li><p>获得互斥锁<br><code>void omp_set_lock(omp_lock_t* lock);</code><br>程序进入进程互斥部分的标志</p>
</li>
<li><p>释放互斥锁<br><code>void omp_unset_lock(omp_lock_t* lock);</code><br>程序退出进程互斥部分的标志</p>
</li>
<li><p>尝试获得互斥锁<br><code>bool omp_set_lock(omp_lock_t* lock);</code><br>尝试获得互斥锁, 成功返回1(true), 失败返回0(false)</p>
</li>
</ul>
<ol start="16">
<li>omp_set_dynamic</li>
</ol>
<p>设置是否允许在运行时动态调整并行区域的线程数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">omp_set_dynamic</span><span class="params">(<span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数为非0时,系统会自动调整线程以最佳利用系统资源.<br>当参数为0时, 动态调整被禁用.<br>此参数即相当于一个布尔型(bool)</p>
<ol start="17">
<li>omp_get_dynamic</li>
</ol>
<p>返回当前程序是否允许动态调整<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">omp_get_dynamic</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>返回非0时表示允许, 0表示不允许.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        
<div class="counter-tag counter">
    <span id="/2020/02/10/OpenMP/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="OpenMP学习记录">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-扑克游戏" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/12/15/扑克游戏/" class="article-date">
  	<time datetime="2019-12-15T02:06:18.000Z" itemprop="datePublished">2019-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/15/扑克游戏/">
        扑克游戏
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简陋规则五张牌的扑克游戏程序设计"><a href="#简陋规则五张牌的扑克游戏程序设计" class="headerlink" title="简陋规则五张牌的扑克游戏程序设计"></a>简陋规则五张牌的扑克游戏程序设计</h2><ul>
<li>代码实现：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*算法思想：</span></span><br><span class="line"><span class="comment">1. 创建玩家和人机各自的随机数数组，用于生成手牌，通过创建随机数函数向双方随机数数组中生成等量随机数作为手牌。</span></span><br><span class="line"><span class="comment">2. 创建双方的二叉排序树，用于存储并排序各自生成的手牌。</span></span><br><span class="line"><span class="comment">3. 创建双方的手牌链表，并中序遍历各自的二叉排序树，将每次遍历到的手牌用尾插法插入链表，得到降序的手牌链表</span></span><br><span class="line"><span class="comment">4. 程序提示玩家先出牌。</span></span><br><span class="line"><span class="comment">5. 人机会在1秒之后做出反应，有牌大的过（即链表表头元素大于对方出牌）则出牌，否则不出，玩家继续出牌。</span></span><br><span class="line"><span class="comment">6. 若人机大的过且出牌，则判断用户是否大的过，若是，则用户出牌，若用户要不起，则提示没有牌可大的过</span></span><br><span class="line"><span class="comment">7. 步骤5和6循环执行，直至一方出牌完毕，程序提示胜负结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span>  <span class="comment">//二叉排序树节点定义 </span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;*BSTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span>  <span class="comment">//链表定义 </span></span><br><span class="line">    <span class="keyword">int</span> card;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_List</span><span class="params">(LinkList *L)</span></span>;  <span class="comment">//链表的初始化 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tail_Ins</span><span class="params">(LinkList L, <span class="keyword">int</span> ins)</span></span>;  <span class="comment">//链表的尾插法创建函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(BSTree *T,<span class="keyword">int</span> value)</span></span>;  <span class="comment">//二叉排序树的插入函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del_Link</span><span class="params">(LinkList L, <span class="keyword">int</span> x)</span></span>;  <span class="comment">//二叉排序树的删除函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree_to_List</span><span class="params">(BSTree root, LinkList one_LinkList)</span></span>;  <span class="comment">//将一个二叉排序树中的值存到链表中 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mknumber</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span>;  <span class="comment">//生成5个随机数并存入array数组中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cards</span><span class="params">(<span class="keyword">int</span> user[], <span class="keyword">int</span> computer[])</span></span>;  <span class="comment">//生成用户和人机的手牌 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">(BSTree *user_tree, BSTree *computer_tree)</span></span>;  <span class="comment">//建立两个二叉排序树 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display_cards</span><span class="params">(LinkList L)</span></span>;  <span class="comment">//显示用户或人机的手牌 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Computer_against</span><span class="params">(LinkList computer_list, <span class="keyword">int</span> card)</span></span>;  <span class="comment">//人机的出牌模式 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computer_show</span><span class="params">(LinkList L, <span class="keyword">int</span> card)</span></span>;  <span class="comment">//人机在出牌后亮出所出的牌</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computer_del</span><span class="params">(LinkList L, <span class="keyword">int</span> card, <span class="keyword">int</span> x)</span></span>; <span class="comment">//人机出牌后删除链表中相应的牌 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Exist</span><span class="params">(LinkList L, <span class="keyword">int</span> card)</span></span>;  <span class="comment">//判断用户想要出的牌是否存在 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">User_against</span><span class="params">(LinkList user_list, <span class="keyword">int</span> card)</span></span>;  <span class="comment">//用户的出牌函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Show_card</span><span class="params">()</span></span>;  <span class="comment">//判断用户出的牌是否正确 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Out_List</span><span class="params">(LinkList L, <span class="keyword">int</span> *x)</span></span>;  <span class="comment">//出牌时对相应链表中值的删除 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Welcome</span><span class="params">(BSTree <span class="keyword">user_t</span>, BSTree <span class="keyword">computer_t</span>, LinkList user_l, LinkList computer_l)</span></span>;  <span class="comment">//菜单函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Game_begins</span><span class="params">(LinkList user_list, LinkList computer_list)</span></span>; <span class="comment">//游戏开始函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear_tree</span><span class="params">(BSTree root)</span></span>;  <span class="comment">//清除二叉排序树中的所有节点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear_list</span><span class="params">(LinkList L)</span></span>;  <span class="comment">//清除链表中的所有节点 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(BSTree <span class="keyword">user_t</span>, BSTree <span class="keyword">computer_t</span>, LinkList user_l, LinkList computer_l)</span></span>; <span class="comment">//清除所有信息 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_List</span><span class="params">(LinkList *L)</span></span>&#123;</span><br><span class="line">    (*L) = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tail_Ins</span><span class="params">(LinkList L, <span class="keyword">int</span> ins)</span></span>&#123; <span class="comment">//尾插法创建</span></span><br><span class="line">    LinkList s;</span><br><span class="line">    s = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">    s-&gt;next = L-&gt;next;</span><br><span class="line">    s-&gt;card = ins;</span><br><span class="line">    L-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display_cards</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LinkList temp = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp-&gt;card);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del_Link</span><span class="params">(LinkList L, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    LinkList pre = L;</span><br><span class="line">    LinkList temp = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(temp &amp;&amp; temp-&gt;card != x)&#123;</span><br><span class="line">        pre = temp;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;card == x)&#123; </span><br><span class="line">        pre-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Out_List</span><span class="params">(LinkList L, <span class="keyword">int</span> *x)</span></span>&#123;</span><br><span class="line">    LinkList temp = L-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(temp)&#123;</span><br><span class="line">        *x = temp-&gt;card;</span><br><span class="line">        L-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"No card.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tree_to_List</span><span class="params">(BSTree root, LinkList one_LinkList)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        Tree_to_List(root-&gt;rchild, one_LinkList);</span><br><span class="line">        Tail_Ins(one_LinkList, root-&gt;key);</span><br><span class="line">        Tree_to_List(root-&gt;lchild, one_LinkList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(BSTree *T,<span class="keyword">int</span> value)</span></span>&#123;  <span class="comment">//二叉排序树的插入操作</span></span><br><span class="line">    BSTree s;</span><br><span class="line">    <span class="keyword">if</span>((*T) == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        s = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line">        s-&gt;key = value;</span><br><span class="line">        s-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        *T = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &lt;= (*T)-&gt;key)</span><br><span class="line">        Insert(&amp;((*T)-&gt;lchild), value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; (*T)-&gt;key)</span><br><span class="line">        Insert(&amp;((*T)-&gt;rchild), value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mknumber</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span>&#123; <span class="comment">//向一个数组中存储5个随机数</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = rand() % <span class="number">41</span>;</span><br><span class="line">        <span class="built_in">array</span>[i] %= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            i--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_cards</span><span class="params">(<span class="keyword">int</span> user[], <span class="keyword">int</span> computer[])</span></span>&#123;  <span class="comment">//</span></span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>)); <span class="comment">//以系统时间来设置随机数生成器</span></span><br><span class="line">    mknumber(user);</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>)*<span class="number">1234</span>);  <span class="comment">//为使双方手牌不同而重新设置随机数生成器</span></span><br><span class="line">    mknumber(computer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">(BSTree *user_tree, BSTree *computer_tree)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*生成用户和人机手牌的随机数数组，并存储到各自的二叉排序树中*/</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    *user_tree = <span class="literal">NULL</span>;</span><br><span class="line">    *computer_tree = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> user[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> computer[<span class="number">5</span>];</span><br><span class="line">    get_cards(user, computer);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        Insert(user_tree, user[i]);</span><br><span class="line">        Insert(computer_tree, computer[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">computer_show</span><span class="params">(LinkList L, <span class="keyword">int</span> card)</span></span>&#123;</span><br><span class="line">    LinkList temp = L-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> judge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;card &lt;= card &amp;&amp; temp)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;card &gt; card)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The computer show %d.\n"</span>, temp-&gt;card);</span><br><span class="line">        <span class="keyword">return</span> temp-&gt;card;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Computer can't follow.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">computer_del</span><span class="params">(LinkList L, <span class="keyword">int</span> card, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    x = computer_show(L, card);</span><br><span class="line">    <span class="keyword">if</span>(x)</span><br><span class="line">        Del_Link(L, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Exist</span><span class="params">(LinkList L, <span class="keyword">int</span> card)</span></span>&#123;</span><br><span class="line">    LinkList temp = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;card == card)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Game_begins</span><span class="params">(LinkList user_list, LinkList computer_list)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> user_card, computer_card;</span><br><span class="line">    user_card = <span class="number">1000</span>;</span><br><span class="line">    Display_cards(user_list);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Show your card first.\n"</span>);</span><br><span class="line">loop1:<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;user_card);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span>(!Exist(user_list, user_card))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Please show a card which you have.\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> loop1;</span><br><span class="line">    &#125; </span><br><span class="line">    Del_Link(user_list, user_card);</span><br><span class="line">    <span class="keyword">while</span>(user_list-&gt;next &amp;&amp; computer_list-&gt;next)&#123;</span><br><span class="line">        computer_card = Computer_against(computer_list, user_card);</span><br><span class="line">        <span class="keyword">if</span> (!computer_list-&gt;next)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Computer show %d.\n"</span>, computer_card);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(computer_card)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!user_list-&gt;next)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            user_card = User_against(user_list, computer_card);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!user_list-&gt;next)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Show your card in the new round.\n"</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Your cards are: \n"</span>);</span><br><span class="line">            Display_cards(user_list);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Show your Card:\n"</span>);</span><br><span class="line">    loop2:	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;user_card);</span><br><span class="line">            <span class="keyword">if</span>(!Exist(user_list, user_card))</span><br><span class="line">                <span class="keyword">goto</span> loop2;</span><br><span class="line">            Del_Link(user_list, user_card); </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(user_card)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">    loop:	<span class="keyword">if</span> (!computer_list-&gt;next)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            Sleep(<span class="number">1000</span>);</span><br><span class="line">            Out_List(computer_list, &amp;computer_card);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Computer show %d.\n"</span>, computer_card);</span><br><span class="line">            <span class="keyword">if</span> (!computer_list-&gt;next)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"It's your turns.\n"</span>);</span><br><span class="line">            user_card = User_against(user_list, computer_card);</span><br><span class="line">            <span class="keyword">if</span>(!user_card)</span><br><span class="line">                <span class="keyword">goto</span> loop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!user_list-&gt;next)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"You win!\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!computer_list-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"You lose!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"System error!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Computer_against</span><span class="params">(LinkList computer_list, <span class="keyword">int</span> card)</span></span>&#123;</span><br><span class="line">    Sleep(<span class="number">1000</span>);</span><br><span class="line">    LinkList temp = computer_list-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> computer_card;</span><br><span class="line">    <span class="keyword">int</span> judge;</span><br><span class="line">    judge= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;card &gt; card)&#123;</span><br><span class="line">            computer_card = temp-&gt;card;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Computer show %d.\n\n"</span>, temp-&gt;card);</span><br><span class="line">            Del_Link(computer_list, temp-&gt;card);</span><br><span class="line">            judge = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge)</span><br><span class="line">        <span class="keyword">return</span> computer_card;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Card's number is too large to against.\n\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">User_against</span><span class="params">(LinkList user_list, <span class="keyword">int</span> card)</span></span>&#123;</span><br><span class="line">    LinkList temp = user_list-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> user_card;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next)</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;card &lt;= card)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"You have no card to against opponent.\n\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Your cards are: \n"</span>);</span><br><span class="line">    Display_cards(user_list);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Show your card now:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;user_card);</span><br><span class="line">    <span class="keyword">while</span>(user_card &lt;= card || !Exist(user_list, user_card))&#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span>(user_card &lt;= card)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Opponent show %d, please show a card larger than it.\n"</span>, card);</span><br><span class="line">        <span class="keyword">if</span>(!Exist(user_list, user_card))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Please show a card which you have.\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;user_card);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Del_Link(user_list, user_card);</span><br><span class="line">    <span class="keyword">return</span> user_card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Show_card</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> card;</span><br><span class="line">    <span class="keyword">int</span> judge;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        judge=<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;card);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,card);</span><br><span class="line">        <span class="keyword">if</span>( judge==<span class="number">1</span>&amp;&amp;card &gt; <span class="number">1</span> &amp;&amp; card &lt; <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Please input a number of one of your cards.\n"</span>);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> card;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Welcome</span><span class="params">(BSTree <span class="keyword">user_t</span>, BSTree <span class="keyword">computer_t</span>, LinkList user_l, LinkList computer_l)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> chioce;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        system(<span class="string">"cls"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------------------------------------------------------\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	     ,            _..._            ,              |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	    &#123;'.         .'     '.         .'&#125;             |\n"</span>); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	   &#123; ~ '.      _|=    __|_      .'  ~&#125;            |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	  &#123; ~  ~ '-._ (___________) _.-'~  ~  &#125;           |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	 &#123;~  ~  ~   ~.'           '. ~    ~    &#125;          |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	&#123;  ~   ~  ~ /   /\\     /\\   \\   ~    ~  &#125;         |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	&#123;   ~   ~  /    __     __    \\ ~   ~    &#125;         |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	 &#123;   ~  /\\/  -&lt;( o)   ( o)&gt;-  \\/\\ ~   ~&#125;          |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	  &#123; ~   ;(      \\/ .-. \\/      );   ~ &#125;           |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	   &#123; ~ ~\\_  ()  ^ (   ) ^  ()  _/ ~  &#125;            |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	    '-._~ \\   (`-._'-'_.-')   / ~_.-'             |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|		'--\\   `'._'__'_.'`  /--'                 |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	            \\      \\`-'/    /                     |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	            `\\     '-'     /'                     |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	             `\\           /'                      |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	              `\\         /'                       |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"|	                ''-...-''                         |\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-----------------------------------------------------------\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Input '1' to play porker game.\n"</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;chioce);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span>(chioce != <span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Your cards are:\n"</span>);</span><br><span class="line">        Init_List(&amp;user_l);</span><br><span class="line">        Init_List(&amp;computer_l);</span><br><span class="line">        Create(&amp;<span class="keyword">user_t</span>, &amp;<span class="keyword">computer_t</span>);</span><br><span class="line">        Tree_to_List(<span class="keyword">user_t</span>, user_l);</span><br><span class="line">        Tree_to_List(<span class="keyword">computer_t</span>, computer_l);</span><br><span class="line">    <span class="comment">//	Display_cards(computer_l);</span></span><br><span class="line">        Game_begins(user_l, computer_l);</span><br><span class="line">        Clear(<span class="keyword">user_t</span>, <span class="keyword">computer_t</span>, user_l, computer_l);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Game over.\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"You can input '1' to play this game again.\n"</span>);</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;chioce);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">if</span>(chioce != <span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear_tree</span><span class="params">(BSTree root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        Clear_tree(root-&gt;lchild);</span><br><span class="line">        Clear_tree(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">free</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear_list</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    LinkList temp;</span><br><span class="line">    <span class="keyword">while</span>(L-&gt;next)&#123;</span><br><span class="line">        temp = L-&gt;next;</span><br><span class="line">        L-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">(BSTree <span class="keyword">user_t</span>, BSTree <span class="keyword">computer_t</span>, LinkList user_l, LinkList computer_l)</span></span>&#123;</span><br><span class="line">    Clear_tree(<span class="keyword">user_t</span>);</span><br><span class="line">    Clear_tree(<span class="keyword">computer_t</span>);</span><br><span class="line">    Clear_list(user_l);</span><br><span class="line">    <span class="built_in">free</span>(user_l);</span><br><span class="line">    Clear_list(computer_l);</span><br><span class="line">    <span class="built_in">free</span>(computer_l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BSTree user_tree, computer_tree;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    LinkList user_list, computer_list;</span><br><span class="line">    Welcome(user_tree, computer_tree, user_list, computer_list);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        
<div class="counter-tag counter">
    <span id="/2019/12/15/扑克游戏/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="扑克游戏">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-高效学习计算机专业课程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/28/高效学习计算机专业课程/" class="article-date">
  	<time datetime="2019-07-28T11:09:47.000Z" itemprop="datePublished">2019-07-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/28/高效学习计算机专业课程/">
        高效学习计算机专业课程
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>计算机专业各种骨干核心课程中包容了计算机科学中最基础的知识，计算机专业课程难度较大，可锻炼自身思维能力。计算机专业的学习与实用应用型知识的学习相互促进</p>
<h2 id="计算机专业课程："><a href="#计算机专业课程：" class="headerlink" title="计算机专业课程："></a>计算机专业课程：</h2><ul>
<li><p>必修课：计算机专业的核心课程，代表着一名计算机专业学生应该具备的计算机科学理论和基础（最重要的四门）：</p>
<ol>
<li><p>数据结构与算法<br><img src="/Pictures/1564308718079.jpeg" alt="alt"><br> 数据结构表示信息的本身，算法表示信息的处理过程，数据结构与算法不能分开</p>
<p> 课程大致分为两大块：</p>
<ul>
<li>数据结构与算法的理论基础：弄明白概念和术语，掌握如何设计算法，如何评价一个算法的优劣</li>
<li>具体的数据结构和算法的介绍：通常只需要掌握最常用的几种，没有必要每个都去深究，每种数据结构和算法往往都有特定的应用场景，用来解决特定的问题。</li>
<li>学算法之前建议先掌握离散数学</li>
<li>对于算法，能够体会它的思想，知道应用场景和优缺点就足够，具体应用中需要自己设计算法的场景并不多</li>
<li>各种编程语言或者开发框架中都给出了算法的组件，大多能理解用途，会调用就可以</li>
</ul>
</li>
<li><p>计算机组成原理<br> <img src="/Pictures/1564310058238.jpeg" alt="alt"><br> 介绍了计算机系统是由哪些部件组成的，这些部件之间是如何相互协作完成数据处理功能，同时又能满足成本、功耗等指标的。</p>
<p> 学习这门课前通常需要学习数字电路基础,建议先学习《编码》（强烈推荐），学完这门课后可进一步学习操作系统和编译原理</p>
<p> 学习内容：</p>
<ul>
<li>计算机系统的概述</li>
<li>指令集设计</li>
<li>处理器结构</li>
<li>I/O与存储系统与设计</li>
<li>并行计算（硕士）</li>
<li>云计算（硕士）</li>
</ul>
</li>
<li><p>操作系统<br><img src="/Pictures/1564310294277.jpeg" alt="alt"><br> 位于多数软件开发工作的第”N-1”层，必须很好地掌握.</p>
<p> 学习之前必须学号数据结构与算法，也需要掌握计算机组成原理的基础，还要掌握C语言</p>
<p> 学习关键：<br> <img src="/Pictures/1564310530249.jpeg" alt="alt"><br> 必须要将其与软件开发以及动手实验结合起来</p>
<p> Linux：在互联网和嵌入式开发占主导地位<br> Windows：桌面应用与行业应用</p>
</li>
<li><p>计算机网络<br><img src="/Pictures/1564310760424.jpeg" alt="alt"><br>掌握相应的网络协议是掌握各种上层应用软件开发技术的关键。最大的特点就是分层：</p>
<p>《计算机网络：自顶向下方法》就是从上层协议介绍到下层协议</p>
<p>《计算机网络》Andrew S.Tanebaum：自下而上来介绍</p>
<p>《计算机网络：系统方法》则以横切的方式，针对一个特定的网络问题来展开介绍</p>
<p>弄清楚三个问题：</p>
<ol>
<li>计算机是如何连接的</li>
<li>数据是怎样在计算机网路中传输的</li>
<li>网络应用软件系统是怎样构建起来的</li>
</ol>
<p>学习建议：</p>
<ul>
<li>理解分层的概念，清楚每一层所解决的主要问题是什么，面临的主要问题是什么，设计者针对这一问题的解决方案是什么，应用了哪些基本原理，有哪些常用的算法</li>
<li>阅读科普书籍入门计算机网络</li>
<li>动手用编程语言结合计算机网络协议来完成一些简单的任务</li>
<li>应用层次的学习：重点学习HTTP协议并掌握面向对象知识</li>
<li>学习网络抓包工具巩固计算机网络的基础</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>ACM总结的18个计算机科学关键领域：</p>
<p><img src="/Pictures/1564313211141.jpeg" alt="alt"><br><img src="/Pictures/IMG_20190728_192718.jpg" alt="alt"></p>
<ul>
<li>对知识的掌握程度（三级）：<ol>
<li>Familiarity（了解）：What do you know about this? (你对它了解多少？)</li>
<li>Usage（会用）：What do you know how to do?(关于怎样做，你知道多少？)</li>
<li>Assessment（评估与决断）：Why would you do that?（为什么要这么做？）  </li>
</ol>
</li>
<li>针对特定的场景和特定的问题能找到多种解决方案，并能够对这些方案进行评估从中选出合适的来应用</li>
<li>ACM报告：软件工程知识领域中有关软件过程的知识集合，衡量对这些知识的掌握程度。</li>
<li>自学的核心任务：这18个核心领域之间有着紧密的联系，形成一个知识网络，构建这个知识网络就是自学的核心任务</li>
</ul>
</li>
</ul>
<p><img src="/Pictures/1564216063029.jpeg" alt="avatar"></p>
<ul>
<li>对计算机专业有了一定认识后要做两件事<ol>
<li>掌握一门编程语言：<br>这4种编程语言基本上是从事计算机行业所必须会掌握的语言，从哪一门入手都可以。<ul>
<li>C</li>
<li>Java</li>
<li>Java Script</li>
<li>Python</li>
</ul>
</li>
<li>学好数学</li>
</ol>
</li>
</ul>
<h2 id="学习方法："><a href="#学习方法：" class="headerlink" title="学习方法："></a>学习方法：</h2><ul>
<li><img src="/Pictures/1564217426707.jpeg" alt="avatar"></li>
<li>知识组块：根据知识的内在逻辑和意义吧相关联的信息碎片理解和重组而建立</li>
<li>人类的学习过程，就是把吸收的知识转换为知识组块存入人的长期记忆中的过程</li>
<li><img src="/Pictures/1564217879671.jpeg" alt="avatar"></li>
<li><img src="/Pictures/高效学习计算机专业课程1564218080443.jpeg" alt="场景式学习方式">(学以致用)<ul>
<li>根据特定场景分析特定的需求，确定学习的目的，有选择地读特定的书，读书中特定的部分，进行特定的实践，形成特定的知识组块，组合这些组块去解决特定的问题</li>
</ul>
<ol>
<li>针对具体的场景，根据场景需求，搜集各种资源，构建知识框架</li>
<li>通过学习，不断向原本的框架补充内容</li>
<li>建立好知识框架，解决问题所需要的知识组块全部准备就位就可以着手解决实际问题</li>
</ol>
</li>
<li><img src="/Pictures/高效学习计算机专业课程1564218087879.jpeg" alt="有效学的的基本原则"></li>
<li>学习需要循序渐进：<ul>
<li>请教高人指导学习路线</li>
<li>对于经典的书籍，看不懂时候不要硬着头皮看，效率会很低，要记录下看不懂的地方，停下来弄明白看不懂的原因，是否是没有掌握某些基础的东西，若是则先放一放，掌握基础后再来。</li>
</ul>
</li>
<li>将学习划分为各个阶段，给每个阶段制定一个明确的目标和任务，生成学习的进度条，有助于增强学习动力</li>
<li><p>真正有效的学习：<br><img src="/Pictures/1564311904162.jpeg" alt="alt"></p>
<p>最初学到的只是些孤立的知识点，通过消化吸收和实践，知识点连接起来形成知识组块，组块之间再连接就形成知识之网</p>
</li>
</ul>
<p><strong>计算机专业的学习要落实在理论与实践的统一上</strong></p>
<ul>
<li>先实践再理论的学习效果更佳</li>
</ul>
<h2 id="新知识的学习："><a href="#新知识的学习：" class="headerlink" title="新知识的学习："></a>新知识的学习：</h2><ul>
<li>将新学来的知识附着到已经形成的知识网络上、</li>
<li>学习的误区：将各个知识点当做一个个孤立的点去攻克，而忽视新旧知识之间的联系</li>
<li>特定的知识往往要与特定的知识网络相结合后才能真正的学会</li>
</ul>
<h2 id="计算机专业学习的”N-1”与”N-1”"><a href="#计算机专业学习的”N-1”与”N-1”" class="headerlink" title="计算机专业学习的”N+1”与”N-1”"></a>计算机专业学习的”N+1”与”N-1”</h2><p><img src="/Pictures/高效学习计算机专业课程1564218092614.jpeg" alt="alt"><br>清楚自己的需求，掌握和自己的需求关系最紧密的上一层和下一层知识就够了，不需要每方面都做到精通，那是不现实的</p>
<p>从硬件到软件，计算机系统分为多层，每层都分为特定的知识和技术，都对应着特定的工作岗位，要依据期望从事的工作岗位，确定工作的层次，从而清楚自己需要精通的知识集合以及对其他知识集合需要了解和把握的程度</p>
<h2 id="选择书籍的基本原则和方法"><a href="#选择书籍的基本原则和方法" class="headerlink" title="选择书籍的基本原则和方法"></a>选择书籍的基本原则和方法</h2><p>对于经典书籍，在不具备相关的基础和技术经验的前提下，经典对自己是没有意义的</p>
<p>选择一本自己已针对其经拥有一定的实施储备，可以读懂的书来读，书籍作者一般都会在前言假设读者应该具备的基础，若大多陌生，则可以先扫清障碍，留来以后再看。或者如果作者没有在前言明示基础，则可以先读一部分，若开头就读不懂，则仍应先搞基础，暂时放弃这本书</p>
<p><img src="/Pictures/1564278030091.jpeg" alt="alt"></p>
<p>通过浅显易懂的科普书籍入门，通过专业教材来掌握基础并深入学习，再读专业技术书籍</p>
<p>建议多阅读英文书籍，或中英文书籍</p>
<p>读书时多注意专业术语的中英文翻译的对照，可做成一个表格。</p>
<p><strong>多遍阅读法</strong><br><img src="/Pictures/1564278190978.jpeg" alt="alt"></p>
<ul>
<li>认真读书的前言，目录和序言。</li>
<li>快速浏览开头和结尾，掌握哪些部分细读，哪些部分略读</li>
<li>第一遍重点看章节中的特定的应用场景和要解决的问题、结论和观点，不要深究细节</li>
<li>第二遍多在干货上下功夫</li>
<li>读第四遍之前要查找资料，学习完基础后再开始</li>
<li>大部分书籍只需要读第一遍和第二遍即可</li>
</ul>
<h2 id="攻克难懂的经典书籍"><a href="#攻克难懂的经典书籍" class="headerlink" title="攻克难懂的经典书籍"></a>攻克难懂的经典书籍</h2><ul>
<li>读科普书籍或文章，通过亲手练习来获取特定领域的背景知识</li>
<li>对于数学公式较多的书籍，先弄明白作者所用的知识是哪方面的数学，先学习相应的数学基础再来参照着读这类书籍</li>
<li>有些系列的书是建立在另一本书看完的基础上，必须先读基础的书<br><img src="/Pictures/1564302342942.jpeg" alt="alt"></li>
</ul>
<h2 id="计算机与数学"><a href="#计算机与数学" class="headerlink" title="计算机与数学"></a>计算机与数学</h2><p><img src="/Pictures/1564307204446.jpeg" alt="alt"><br>线性代数是数字图像处理的基础</p>
<p>概率论与数理统计是大数据和人工智能的基础</p>
<h2 id="计算机全局观的建立"><a href="#计算机全局观的建立" class="headerlink" title="计算机全局观的建立"></a>计算机全局观的建立</h2><p>读计算机专业概论，粗略的知道这个领域所涵盖的知识面，并了解自己当前所学的知识在整个计算机领域中的地位</p>
<p>选择最新版本的专业概论书籍</p>
<h2 id="书籍推荐："><a href="#书籍推荐：" class="headerlink" title="书籍推荐："></a>书籍推荐：</h2><ul>
<li>《浪潮之巅》吴军： 主要讲述IT产业发展的脉络和硅谷明星公司的兴衰沉浮</li>
<li>《数学之美》吴军： 介绍数学在计算机领域的具体应用</li>
<li>《学习之道》：针对学习的研究成果，用来改进学习方法</li>
<li>《微积分读本》普林斯顿：采用内心独白的方式介绍微积分，能够比较顺利的读懂</li>
<li>《离散数学及其应用》（机械工业出版社）</li>
<li>《线性代数及其应用》：展示线性代数在应用中的案例，更容易了解这门课的用途</li>
<li>《计算机科学概论》Nell Dale：采用剥洋葱方式从内向外介绍计算机科学</li>
<li>《计算机科学概论》J.Glenn Brookshear：由每个主题自然而然地引导出下一个主题，由具体到抽象</li>
<li>《算法图解》</li>
<li>《算法导论》：针对特定算法的数学分析与证明</li>
<li>《Linux》内核</li>
<li>《编码》Charies Petzold</li>
<li>《计算机网络：自顶向下方法》</li>
<li><p>《深入理解计算机系统》：从使用者而不是从计算机系统设计者的角度来组织材料<br><img src="/Pictures/1564308330214.jpeg" alt="alt"><br>并不适合零基础入门，阅读者至少应该学过计算机科学的导论，并有一些C语言和Linux的开发经验</p>
<p>这本书能够帮助读者将零散的知识组块化，在建立组块之间的联系，可以通过这本书了解计算机系统的整体设计，明白这些设计因素对于应用软件开发和运行的影响，建立一个完整的计算机专业知识体系和整体的知识框架，在这个框架之上再选择有针对性的书籍钻研特定的子领域</p>
</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        
<div class="counter-tag counter">
    <span id="/2019/07/28/高效学习计算机专业课程/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="高效学习计算机专业课程">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-nvme" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/07/17/nvme/" class="article-date">
  	<time datetime="2019-07-17T01:18:14.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/nvme/">
        无M.2的老台式实现NVME固态硬盘支持
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="无M-2的老台式实现NVME固态硬盘支持"><a href="#无M-2的老台式实现NVME固态硬盘支持" class="headerlink" title="无M.2的老台式实现NVME固态硬盘支持"></a>无M.2的老台式实现NVME固态硬盘支持</h2><p>在升级自己老式台式机时总会遇见接口过于古老或协议不支持的情况，比如给一些老式主板升级的话不想接SATA这种相对NVME慢几倍的固态硬盘，而主板上又没有M.2的接口，甚至不支持NVME协议，老主板刷BIOS的话也会有风险，处境就非常尴尬。这篇就将介绍如何给无M.2接口甚至不支持NVME协议的主板升级NVME固态硬盘。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具:"></a>工具:</h3><ol>
<li><p>M.2转PCI-E 3.0*4转接卡(淘宝搜索后购买)</p>
</li>
<li><p>U盘 (只需要200M就够了，是块U盘就可以)</p>
</li>
<li><p>软件：BD Utility(Boot Disk Utility)</p>
</li>
</ol>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>将硬盘装在转接卡上连接主机</p>
<p>下载BDUtility：官网为<a href="http://cvad-mac.narod.ru/index/bootdiskutility_exe/0-5" target="_blank" rel="noopener">http://cvad-mac.narod.ru/index/bootdiskutility_exe/0-5</a><br>也可以到网盘下载：链接：<a href="https://pan.baidu.com/s/1SVR6RPyh6U2pnNwYxPpQeQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1SVR6RPyh6U2pnNwYxPpQeQ</a>提取码：wtn6</p>
<p>下载完成后解压，插上U盘，打开BDUtility，选择U盘，点击Format，软件会从服务器下载各种模块安装，等几分钟后显示All done就表示引导盘已经做好。</p>
<p><strong><em>关键部分</em></strong>：BootDiskUtility将U盘分成了一个200MB的FAT32分区CLOVER和一个未分区区块，引导装在这个CLOVER分区中，打开它，找到<code>EFI\CLOVER\drivers-Off\drivers64UEFI</code>文件夹下的<code>NVMExpressDxe-64.efi</code>文件, 分别将它复制到： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EFI\CLOVER\drivers64  </span><br><span class="line">EFI\CLOVER\drivers64UEFI</span><br></pre></td></tr></table></figure>
<p>两个目录下，就大功告成了！</p>
<p>最后，重启电脑，进入BIOS，将刚做好的U盘引导盘作为第一启动盘，从U盘引导启动，启动后会出现引导菜单，默认第一个盘符就是NVME的引导分区，按回车选择或者等待自动选择就会成功进入系统。</p>
<p>至于固态硬盘中的系统，我的是在另一个电脑上装好之后才插到老台式上的，如果硬盘没有操作系统，需要装系统的话，插上另一个系统引导盘按常规操作来就行。如果装系统时系统引导U盘找不到NVME的分区的话还是建议在另一台电脑上装好系统后直接引导。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        
<div class="counter-tag counter">
    <span id="/2019/07/17/nvme/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="无M.2的老台式实现NVME固态硬盘支持">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-HotKey" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/06/08/HotKey/" class="article-date">
  	<time datetime="2019-06-08T03:18:21.000Z" itemprop="datePublished">2019-06-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/08/HotKey/">
        HotKey
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="利用AutoHotKey实现常用操作的快捷键设置（充分利用CapsLock键）"><a href="#利用AutoHotKey实现常用操作的快捷键设置（充分利用CapsLock键）" class="headerlink" title="利用AutoHotKey实现常用操作的快捷键设置（充分利用CapsLock键）"></a>利用AutoHotKey实现常用操作的快捷键设置（充分利用CapsLock键）</h1><ol>
<li>下载AutoHotKey:<a href="https://www.autohotkey.com/" target="_blank" rel="noopener">https://www.autohotkey.com/</a></li>
<li>在任一目录下右击-&gt;新建-&gt;AutoHotKey Script-&gt;输入文件名（或新建.txt文本文档，将扩展名改为.ahk）eg: AutoHotKey.ahk</li>
<li>右击新建好的文件AutoHotKey.ahk，选择打开方式，选择AutoHotKey，勾选始终用此应用打开.ahk文件</li>
<li>编辑AutoHotKey.ahk，此操作可以有多种方法<ul>
<li>直接右键点编辑</li>
<li>VsCode打开 （推荐）</li>
</ul>
</li>
<li>在编辑器中打开后,进入<br><a href="https://github.com/GavinWz/DailyCodes/blob/master/HotKey/CapsLock.ahk" target="_blank" rel="noopener">https://github.com/GavinWz/DailyCodes/blob/master/HotKey/CapsLock.ahk</a><br>将AutoHotKey.ahk中的代码复制下来粘贴到自己的文件中，并保存。</li>
<li>打开自己的AutoHotKey.ahk文件，即可运用其中的所有快捷键。</li>
<li>每次开机都需要运行一遍的话会比较麻烦，将源文件放到开机自启文件夹中即可</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        
<div class="counter-tag counter">
    <span id="/2019/06/08/HotKey/" class="leancloud_visitors post-title-link" style="font-size: 12px" data-flag-title="HotKey">
         &nbsp;
        view
    </span>
</div>

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2020 Weizhe Yang
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>